<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="_csrf" th:content="${_csrf.token}"/>
    <meta name="_csrf_header" th:content="${_csrf.headerName}"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000">
    <link rel="manifest" th:href="@{/manifest.json}">
    <link rel="apple-touch-icon" sizes="192x192" th:href="@{/assets/icons/icon-192.png}">
    <title>GoalClips - Feed</title>
    
    <link rel="stylesheet" th:href="@{/css/style.css(v=${cssVersion})}">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <script th:src="@{/service-worker-register.js}" defer></script>

<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
    overflow-y: hidden !important;
    overflow: hidden;
}

body {
    background: #0B0B0B;
    color: white;
    min-height: 100vh;
    font-family: 'Roboto', -apple-system, BlinkMacSystemFont, sans-serif;
    overflow-x: hidden;
    overflow-y: hidden;
    padding-bottom: 0px;
}

.main-content-scrollable {
    /* REMPLAC√â : On enl√®ve le padding car le header et la nav sont masqu√©s */
    padding-top: 0; 
    /* CORRIG√â : On fixe la hauteur √† l'√©cran entier */
    height: 100vh; 
    overflow-y: scroll;
    /* ESSENTIEL pour l'effet TikTok/Reels: ancre le scroll sur chaque vid√©o */
    scroll-snap-type: y mandatory; 
}
.club-nav, .events-cta-banner {
    display: none !important; /* Seuls ces √©l√©ments restent masqu√©s */
}
/* Le 'header' doit maintenant √™tre g√©r√© par les r√®gles de positionnement */



/* Garder la navbar inf√©rieure */
.mobile-navbar {
    z-index: 100; 
}
.post-goal-navbar-btn {
    z-index: 100;
}

.no-scrollbar::-webkit-scrollbar { display: none; }
.no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

.no-main-scroll { overflow: hidden !important; }

header {
    position: fixed; top: 0; left: 0; width: 100%; height: 60px;
    
    /* CORRIG√â: S'assurer que le fond est transparent */
    background: transparent; 
    
    display: flex; 
    justify-content: space-between;
    align-items: center; 
    padding: 0 1rem; 
    z-index: 50;
    
    /* CORRIG√â: Retirer la bordure qui pourrait appara√Ætre */
    border-bottom: none; 
}

.header-logo { 
    display: flex; 
    align-items: center; 
    gap: 0.5rem; 
    /* NEW: Assurer que le logo et le texte sont au-dessus de tout */
    z-index: 51; 
}
.header-logo i, .header-logo span, .header-icons button {
    color: white !important; 
    /* Ajout de !important au cas o√π une autre r√®gle √©crase */
    text-shadow: 0 0 5px rgba(0,0,0,0.5); /* Ombre pour la lisibilit√© sur fond clair */
}
.header-logo span { font-size: 1rem; font-weight: bold; }

.header-icons { 
    display: flex; 
    align-items: center; 
    gap: 1rem; 
    
    /* NEW: Positionner explicitement √† droite */
    z-index: 51;
}
.header-icons img { 
    width: 32px; 
    height: 32px; 
    border-radius: 50%; 
    
    /* CORRIG√â: Assurer une bordure blanche pour contraster */
    border: 2px solid white; 
}
.header-icons button { background: none; border: none; color: white; font-size: 1.3rem; cursor: pointer; }

.menu-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.95); backdrop-filter: blur(6px);
    display: none; flex-direction: column; padding: 2rem 1rem; z-index: 100;
}
.menu-overlay.active { display: flex; }
.menu-overlay .close-btn { align-self: flex-end; font-size: 1.5rem; cursor: pointer; margin-bottom: 2rem; }
.menu-overlay a { color: white; text-decoration: none; font-size: 1.2rem; padding: 0.75rem 0; border-bottom: 1px solid #222; }

.club-nav {
    position: fixed; top: 60px; width: 100%; background: #0B0B0B;
    display: flex; overflow-x: scroll; padding: 0.75rem 1rem; gap: 1rem;
    z-index: 40; border-bottom: 1px solid #1a1a1a; scroll-behavior: smooth;
}

.club-item { flex-shrink: 0; display: flex; flex-direction: column; align-items: center; text-decoration: none; color: #888; font-size: 0.7rem; gap: 0.3rem; }
.club-item.active { color: white; }
.club-icon { width: 50px; height: 50px; border-radius: 50%; background: #1a1a1a; border: 2px solid #1a1a1a; display: flex; justify-content: center; align-items: center; }
.club-item.active .club-icon { border-color: #10B981; }
.club-add-button { background: #10B981; color: white; font-size: 1.2rem; }

.mobile-navbar { position: fixed; bottom: 0; left: 0; width: 100%; height: 70px; background: #1a1a1a; display: flex; justify-content: space-around; align-items: center; box-shadow: 0 -4px 15px rgba(0,0,0,0.5); z-index: 45; padding: 0 10px; }
.nav-item { display: flex; flex-direction: column; align-items: center; color: #888; text-decoration: none; font-size: 0.7rem; transition: color 0.2s ease; flex: 1; padding: 0.5rem 0; }
.nav-item.active { color: #10B981; }
.nav-item i { font-size: 1.4rem; margin-bottom: 4px; }
.nav-spacer { flex: 1; max-width: 70px; }

.post-goal-navbar-btn {
    position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%);
    width: 65px; height: 65px; border-radius: 50%; background: #10B981;
    display: flex; justify-content: center; align-items: center; color: white;
    font-size: 1.8rem; border: 5px solid #0B0B0B;
    box-shadow: 0 6px 25px rgba(16,185,129,0.6); z-index: 50;
    text-decoration: none; cursor: pointer;
}
.post-goal-label { position: absolute; bottom: -18px; font-size: 0.6rem; font-weight: bold; color: white; white-space: nowrap; text-transform: uppercase; }

@media (min-width: 768px) {
    body { max-width: 480px; margin: 0 auto; box-shadow: 0 0 50px rgba(0,0,0,0.5); }
}
/* Banni√®re Events CTA */
.events-cta-banner {
    margin: 1rem;
    margin-top: 0.5rem; /* Petit espace apr√®s la barre des clubs */
    background: linear-gradient(135deg, #3B82F6 0%, #2563EB 100%);
    border-radius: 12px;
    padding: 1rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    text-decoration: none;
    transition: transform 0.2s ease;
}

.events-cta-banner:active {
    transform: scale(0.98);
}

.events-cta-content {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    flex: 1;
}

.events-cta-icon {
    width: 40px;
    height: 40px;
    background: rgba(255, 255, 255, 0.2);
    border-radius: 10px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 1.2rem;
    color: white;
}

.events-cta-text h4 {
    color: white;
    font-size: 0.95rem;
    font-weight: bold;
    margin-bottom: 0.2rem;
}

.events-cta-text p {
    color: rgba(255, 255, 255, 0.9);
    font-size: 0.75rem;
}

.events-cta-arrow {
    color: white;
    font-size: 1.2rem;
}
.video-card {
    height: 100vh; /* OCCUPE 100% DE LA HAUTEUR */
    scroll-snap-align: start; /* Ancrage pour l'effet "snap" de TikTok */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    position: relative;
    /* Assurez-vous que le conteneur s'ajuste bien */
    width: 100%; 
}

/* La vid√©o elle-m√™me prend le maximum d'espace dans la carte */
.video-element {
    position: absolute;
    width: 100%;
    height: 100%;
    object-fit: contain; /* ‚¨ÖÔ∏è CHANG√â de 'cover' √† 'contain' */
    z-index: 1;
    background: #000; /* Fond noir pour les bandes */
}

/* L'overlay doit √™tre au-dessus de la vid√©o (z-index √©lev√©) */
.video-card .overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 10;
    display: flex;
    flex-direction: row;
    align-items: flex-end;
    justify-content: space-between;
    padding: 20px 10px 100px 10px; /* ‚¨ÖÔ∏è AUGMENT√â le padding bottom */
    pointer-events: none; /* Les clics passent √† travers */
}

/* R√©activer les clics sur les boutons */
.overlay .actions,
.overlay .video-author-link {
    pointer-events: auto;
}

/* D√©placer les √©l√©ments statiques au bas de l'√©cran (comme les likes/commentaires) */
.video-actions {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 1.5rem;
    padding-right: 0.5rem; /* Un peu d'espace √† droite */
}
/* D√©placer les infos de l'utilisateur/titre en bas √† gauche */
.video-info {
    padding-left: 1rem;
    padding-bottom: 1.5rem;
}
.video-crud-actions {
    display: none !important; 
}
.video-card {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    height: 100vh !important;
    width: 100% !important;
    position: relative !important;
}
.video-title {
    font-size: 1rem; /* ‚¨ÖÔ∏è R√©duit si trop grand */
    line-height: 1.3;
    max-width: 70%; /* Limite la largeur */
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2; /* Maximum 2 lignes */
    -webkit-box-orient: vertical;
}
.video-author-overlay {
    font-size: 0.9rem;
    margin-top: 0.5rem;
}

.video-element {
    display: block !important;
    visibility: visible !important;
    opacity: 1 !important;
}
</style>
</head>
<body>

<header>
    <div class="header-logo">
        <i class="fas fa-futbol"></i>
        <span>GOAL CLIPS</span>
    </div>
    <div class="header-icons">
        <img src="https://i.pravatar.cc/150?img=33" alt="Profile">
        <button id="burger-btn"><i class="fa-solid fa-bars"></i></button>
    </div>
</header>

<div class="menu-overlay" id="menu-overlay">
    <span class="close-btn" id="menu-close"><i class="fa-solid fa-xmark"></i></span>
    <a href="/">Feed</a>
    <a href="/events">Events</a>
    <a href="#clubs">Clubs</a>
    <a href="/profile">Profile</a>
    <a href="#settings">Settings</a>
</div>

<nav class="club-nav no-scrollbar">
    <a href="#" class="club-item">
        <div class="club-icon club-add-button"><i class="fa-solid fa-plus"></i></div>
        <span>Ajouter</span>
    </a>
    <a href="#" class="club-item active">
        <div class="club-icon"><i class="fa-solid fa-shield-halved" style="color: #10B981; font-size: 1.5rem;"></i></div>
        <span>Mon Club</span>
    </a>
</nav>

<!--<a href="/events" class="events-cta-banner">
    <div class="events-cta-content">
        <div class="events-cta-icon">
            <i class="fas fa-calendar-star"></i>
        </div>
        <div class="events-cta-text">
            <h4>√âv√©nements √† venir</h4>
            <p>Matchs, tournois et entra√Ænements</p>
        </div>
    </div>
    <i class="fas fa-chevron-right events-cta-arrow"></i>
</a>-->

<div class="main-content-scrollable no-scrollbar">
    <div id="video-container" th:insert="fragments/video-cards :: video-cards(${videos})"></div>
    <div id="loader" style="display: none;"><p>Chargement...</p></div>
</div>

<nav class="mobile-navbar">
    <a href="/" class="nav-item active"><i class="fa-solid fa-house"></i><span>Home</span></a>
    <a href="/events" class="nav-item"><i class="fa-regular fa-calendar-days"></i><span>Events</span></a>
    <div class="nav-spacer"></div>
    <a href="/videos/feed" class="nav-item"><i class="fa-solid fa-clapperboard"></i><span>Clips</span></a>
    <a href="/profile" class="nav-item"><i class="fa-regular fa-user"></i><span>Profile</span></a>
</nav>

<a href="#" class="post-goal-navbar-btn">
    <i class="fa-solid fa-bullseye"></i>
    <span class="post-goal-label">Post Your Goal</span>
</a>

<script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
<script th:inline="javascript">
// Variables globales (reprises de video-feed.html)
let currentPage = /*[[${currentPage}]]*/ 0;
let category = /*[['' + ${category}]]*/ 'general';
const currentUsername = /*[['' + ${#authentication.name != 'anonymousUser' ? #authentication.name : 'nab'} + '']]*/ 'nab';
let loading = false;
let hasMoreVideos = true;
let observer;
let isManuallyMuted = true;
let stompClient = null;
let videoObserver;
const commentsPagination = new Map();
const csrfToken = document.querySelector('meta[name="_csrf"]') ? document.querySelector('meta[name="_csrf"]').content : null;
const csrfHeader = document.querySelector('meta[name="_csrf_header"]') ? document.querySelector('meta[name="_csrf_header"]').content : null;
const activeSubscriptions = new Map();

// Menu burger
const burger = document.getElementById('burger-btn');
const overlay = document.getElementById('menu-overlay');
const closeBtn = document.getElementById('menu-close');

burger.addEventListener('click', () => {
    overlay.classList.add('active');
    document.body.classList.add('no-main-scroll');
});

closeBtn.addEventListener('click', () => {
    overlay.classList.remove('active');
    document.body.classList.remove('no-main-scroll');
});

// TOUTES LES FONCTIONS DE video-feed.html (copie int√©grale du JavaScript)
// Je garde le code complet pour √©viter les bugs

function getAuthHeaders(contentType = 'application/json') {
    const headers = { 'Content-Type': contentType };
    if (csrfHeader && csrfToken) {
        headers[csrfHeader] = csrfToken;
    }
    return headers;
}

function updateMuteIcon(buttonElement, isMuted) {
    const icon = buttonElement ? buttonElement.querySelector('i') : null;
    if (icon) {
        if (isMuted) {
            icon.classList.remove('fa-volume-high');
            icon.classList.add('fa-volume-xmark');
        } else {
            icon.classList.remove('fa-volume-xmark');
            icon.classList.add('fa-volume-high');
        }
    }
}

        function getAuthHeaders(contentType = 'application/json') {
            const headers = { 'Content-Type': contentType };
            if (csrfHeader && csrfToken) {
                headers[csrfHeader] = csrfToken;
            }
            return headers;
        }
        // =======================================================
        // AJOUT : Correction JS pour forcer la mise en page Flexbox (mobile)
        // =======================================================
        function fixVideoTitlePosition() {
            // Cibler tous les titres √† l'int√©rieur de l'overlay des cartes vid√©o
            const videoTitles = document.querySelectorAll('.video-card .overlay .video-title');

            videoTitles.forEach(title => {
                // Appliquer un d√©lai pour s'assurer de s'ex√©cuter apr√®s le script fautif
                setTimeout(() => {
                    // Surcharge le style inline (qui est prioritaire sur le CSS !important)
                    if (window.innerWidth <= 1023) {
                        title.style.position = 'relative';
                        title.style.bottom = 'unset';
                        title.style.left = 'unset';
                        title.style.width = '100%';
                        // Retirer la propri√©t√© 'float' au cas o√π elle aurait √©t√© inject√©e
                        title.style.float = 'none';
                    }
                }, 150); // D√©lai augment√© √† 150ms pour plus de s√©curit√©
            });
        }

 function createCommentElement(comment) {
    const commentId = comment.commentId || comment.id;
    
    // ‚úÖ CORRECTION 1 : Rendre le nom d'auteur robuste
    // 1. Cherche `authorUsername` (DTO), 2. Cherche `author.username` (si l'objet est complet), 3. Sinon 'Anonymous'
    const authorName = comment.authorUsername 
                     || (comment.author ? comment.author.username : 'Anonymous');

                     console.log('createCommentElement => commentId:', commentId, 'authorName:', authorName, 'currentUsername:', currentUsername);
    
    // ‚úÖ CORRECTION 2 : Rendre le contenu robuste (pour √©viter 'undefined')
    const content = comment.content || 'Contenu non disponible';

    // Supprime les espaces et normalise la cha√Æne pour d√©tecter les caract√®res invisibles
const cleanAuthorName = authorName?.trim().normalize();
const cleanCurrentUsername = currentUsername?.trim().normalize();

// Comparaison insensible √† la casse
const isOwner = cleanAuthorName.toLowerCase() === cleanCurrentUsername.toLowerCase();

console.log('isOwner?', isOwner, 
            'authorName:', `"${authorName}"`, 
            'currentUsername:', `"${currentUsername}"`,
            'cleanAuthorName:', `"${cleanAuthorName}"`,
            'cleanCurrentUsername:', `"${cleanCurrentUsername}"`)


    // ‚úÖ CORRECTION 3 : Rendre la date robuste (pour g√©rer 'Invalid Date')
    let dateString = 'Date Invalide';
    if (comment.createdAt) {
        try {
            let dateObject = new Date(comment.createdAt); 
            
            // Si le format direct √©choue, nettoie la cha√Æne (retire les microsecondes excessives)
            if (isNaN(dateObject.getTime())) { 
                // Regex pour couper apr√®s la 3√®me d√©cimale (milli-secondes) et ajouter Z (pour UTC)
                const cleanedDateString = comment.createdAt.replace(/(\.\d{3})\d+/, '$1Z');
                dateObject = new Date(cleanedDateString);
            }
            
            if (!isNaN(dateObject.getTime())) {
                dateString = dateObject.toLocaleTimeString('fr-FR', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
            }
        } catch (e) {
            console.error("Erreur lors du formatage de la date:", e);
        }
    }


    const actionsHtml = isOwner ? `
        <div class="comment-actions">
            <button class="edit-comment-btn" data-comment-id="${commentId}"><i class="fa-solid fa-pen"></i></button>
            <button class="delete-comment-btn" data-comment-id="${commentId}"><i class="fa-solid fa-trash"></i></button>
        </div>
    ` : '';

    console.log('actionsHtml:', actionsHtml);


    return `
        <div class="comment" data-comment-id="${commentId}">
            <div class="comment-header">
                <i class="fa-solid fa-user"></i>
                <span class="comment-username">${authorName}</span>
                <span class="comment-date">${dateString}</span>
                ${actionsHtml}
            </div>
            <p class="comment-content">${content}</p>
        </div>
    `;
}

        /**
 * Retrait imm√©diat d'une carte vid√©o du DOM suite √† un message de suppression (WS).
 * @param {number} videoId L'ID de la vid√©o √† retirer.
 */
function removeVideoCardFromDOM(videoId) {
    const selector = `.video-card[data-video-id="${videoId}"]`;
    const cardToRemove = document.querySelector(selector);
    
    if (cardToRemove) {
        console.log(`üóëÔ∏è Retrait de la carte vid√©o ${videoId} du DOM via WS.`);
        
        // 1. Arr√™ter l'observation de la lecture automatique
        if (videoObserver) {
             videoObserver.unobserve(cardToRemove);
        }
        
        // 2. Retrait de la carte
        cardToRemove.remove();
        
        // 3. R√©initialiser l'observer de scroll si la carte retir√©e √©tait la derni√®re
        // Cela permet de continuer √† charger la page suivante si la derni√®re a √©t√© retir√©e.
        setupIntersectionObserver();
        
        // 4. Optionnel : Forcer un rechargement pour combler le trou
        // Si le nombre de vid√©os dans le DOM tombe trop bas, on charge la suite imm√©diatement.
        if (document.querySelectorAll('.video-card').length < 5) {
            console.log("Moins de 5 vid√©os restantes, tentative de recharger le feed.");
            // loadMoreVideos() v√©rifiera automatiquement l'√©tat loading/hasMore
            loadMoreVideos(); 
        }
    }
    
    // 5. Nettoyer les abonnements de cette vid√©o (TR√àS IMPORTANT pour l'hygi√®ne STOMP)
    const subscriptions = activeSubscriptions.get(videoId);
    if (subscriptions) {
        subscriptions.forEach(sub => sub.unsubscribe());
        activeSubscriptions.delete(videoId);
        console.log(`‚ùå D√©sabonnement nettoy√© pour la vid√©o ${videoId}.`);
    }
}

        // =======================================================
        // 3. GESTION DE LA LECTURE VID√âO (AUTO-PLAY IMMERSIF) - CORRECTION FINALE
        // =======================================================
        function setupMuteToggles() {
            const muteButtons = document.querySelectorAll('.toggle-mute-btn:not([data-mute-listener="true"])');

            muteButtons.forEach(btn => {

                btn.addEventListener('click', (e) => {
                    e.preventDefault();

                    const videoCard = btn.closest('.video-card');
                    const video = videoCard ? videoCard.querySelector('.video-element') : null;
                    
                    if (video) {
                        // INVERSION : ON INVERSE L'√âTAT GLOBAL AU CLIC
                        isManuallyMuted = !isManuallyMuted;
                        
                        // On applique le nouvel √©tat global √† la vid√©o
                        video.muted = isManuallyMuted;
                        
                        // Mettre √† jour l'ic√¥ne imm√©diatement
                        updateMuteIcon(btn, isManuallyMuted);
                        
                    }
                   
                });

                btn.setAttribute('data-mute-listener', 'true');
            });
        }
       // --- NOUVELLE LOGIQUE PLAY/PAUSE (IntersectionObserver pour la fluidit√©) ---
function setupVideoPlayObserver() {
    if (videoObserver) {
        videoObserver.disconnect();
    }
    
    // Seulement 75% est visible pour le comportement "TikTok"
    videoObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const videoElement = entry.target.querySelector('.video-element');
            const muteBtn = entry.target.querySelector('.toggle-mute-btn');

            if (!videoElement) return;

            if (entry.intersectionRatio > 0.75) {
                // VID√âO PRINCIPALE : LECTURE
                videoElement.muted = isManuallyMuted;
                if (videoElement.paused) {
                    videoElement.play().catch(e => {
                        console.warn(`Lecture vid√©o bloqu√©e (Autoplay). For√ßage du mute.`, e.name);
                        videoElement.muted = true;
                        isManuallyMuted = true; // Mise √† jour de l'√©tat global
                        videoElement.play().catch(e => console.error("√âchec d√©finitif.", e.name));
                    });
                }
                if (muteBtn) updateMuteIcon(muteBtn, videoElement.muted);

            } else {
                // AUTRES VID√âOS : PAUSE et MUTE forc√©
                if (!videoElement.paused) {
                    videoElement.pause();
                }
                // Mute forc√© est essentiel pour ne pas consommer de ressources
                videoElement.muted = true;
                if (muteBtn) updateMuteIcon(muteBtn, true);
            }
        });
    }, {
        root: null, // Viewport
        threshold: 0.75 
    });

    // Observez toutes les cartes vid√©o pr√©sentes
    document.querySelectorAll('.video-card').forEach(card => {
        videoObserver.observe(card);
    });
}
        // =======================================================
        // 4. SCROLL INFINI : FONCTIONS
        // =======================================================
      function loadMoreVideos() {
    console.log(`[LOAD] Tentative de chargement de la page : ${currentPage + 1}.`);

    // AJOUTEZ CES ACCOLADES
    if (loading || !hasMoreVideos) {
        console.log("[LOAD] Chargement ignor√© (d√©j√† en cours ou fin du flux).");
        return; // Maintenant, ce return est conditionnel.
    }
    // FIN DE LA ZONE CRITIQUE

    loading = true;
    document.getElementById('loader').style.display = 'block';

    currentPage++;
            let url = `/videos/feed/fragment?page=${currentPage}`;
            if (category && category !== 'null' && category.trim() !== '') {
                url += `&category=${category}`;
            }

            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Erreur de chargement des fragments');
                    }
                    return response.text();
                })
               .then(html => {
    const videoContainer = document.getElementById('video-container');
    
    if (html.trim() === '') {
        hasMoreVideos = false;
        console.log("Fin du flux.");
        const endMessage = document.createElement('p');
        endMessage.textContent = "C'est tout ce que nous avons pour le moment !";
        videoContainer.appendChild(endMessage);
    } else {
        // üî• AJOUT CRITIQUE : Nettoyer AVANT d'ajouter de nouvelles vid√©os
        pruneOldVideos();
        
        videoContainer.insertAdjacentHTML('beforeend', html);
        console.log(`Page ${currentPage} charg√©e.`);
                        
                        // ESSENTIEL : LIE LES √âCOUTEURS DE MUTE/UNMUTE AUX NOUVELLES VID√âOS
                        setupMuteToggles();

                        // üéØ CORRECTION D'ALIGNEMENT POUR LES FRAGMENTS CHARG√âS
                        fixVideoTitlePosition();

                        // üöÄ ABONNEMENT AUX NOUVEAUX TOPICS (Likes & Commentaires)
                        subscribeToNewVideos();

                        setupVideoPlayObserver(); 

                        // Relance l'observation sur la nouvelle derni√®re carte
                        setupIntersectionObserver();
                    }
                })
                .catch(error => {
                    console.error("Erreur de chargement:", error);
                    hasMoreVideos = false;
                })
                .finally(() => {
                    loading = false;
                    document.getElementById('loader').style.display = 'none';
                });
        }

        // =======================================================
// VIRTUALISATION : LIMITER LE NOMBRE DE VID√âOS EN DOM
// =======================================================
function pruneOldVideos() {
    const MAX_VIDEOS_IN_DOM = 10; // Maximum de vid√©os dans le DOM
    const videoCards = document.querySelectorAll('.video-card');
    
    if (videoCards.length > MAX_VIDEOS_IN_DOM) {
        const toRemove = videoCards.length - MAX_VIDEOS_IN_DOM;
        
        console.log(`üóëÔ∏è Suppression de ${toRemove} anciennes vid√©os`);
        
        // Supprimer les vid√©os les plus anciennes (en haut)
        for (let i = 0; i < toRemove; i++) {
            const card = videoCards[i];
            const videoId = card.dataset.videoId;
            
            // 1. D√©sabonner des WebSockets
            const subscriptions = activeSubscriptions.get(videoId);
            if (subscriptions) {
                subscriptions.forEach(sub => sub.unsubscribe());
                activeSubscriptions.delete(videoId);
            }
            
            // 2. Arr√™ter et d√©truire la vid√©o
            const videoElement = card.querySelector('.video-element');
            if (videoElement) {
                videoElement.pause();
                videoElement.removeAttribute('src'); // Lib√®re le buffer
                videoElement.load();
            }
            
            // 3. Retirer du IntersectionObserver
            if (videoObserver) {
                videoObserver.unobserve(card);
            }
            
            // 4. Supprimer du DOM
            card.remove();
            
            console.log(`üóëÔ∏è Vid√©o ${videoId} supprim√©e du DOM`);
        }
    }
}

       function setupIntersectionObserver() {
    // 1. Utilisez une m√©thode de s√©lection plus robuste
    const allVideoCards = document.querySelectorAll('.video-card');
    
    // 2. S√©lectionnez le dernier √©l√©ment du NodeList (m√©thode la plus fiable)
    const lastVideoCard = allVideoCards.length > 0 ? allVideoCards[allVideoCards.length - 1] : null;

    // üí° LOGS DE DEBUG : D√©terminons ce qui se passe
    console.log("Nombre de cartes vid√©o trouv√©es :", allVideoCards.length); 

    // 3. D√©placement du message d'avertissement
    if (!lastVideoCard || !hasMoreVideos) {
        if (!lastVideoCard) {
            // Se d√©clenche UNIQUEMENT si aucune carte n'est trouv√©e (ce qui est le cas pour un √©chec)
            console.warn("[OBSERVER] Aucune carte vid√©o trouv√©e dans le DOM. Arr√™t de l'observation.");
        }
        return;
    }

    // Si on arrive ici, on a une carte et on doit l'observer.

    // D√©connexion de l'ancien observer (important pour la r√©initialisation apr√®s chargement)
    if (observer) {
        observer.disconnect();
    }

 observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            console.log("[OBSERVER] D√©clenchement de l'intersection !");
            observer.unobserve(entry.target);
            loadMoreVideos();
        }
    });
}, {
    root: null,
    // MODIFICATION CL√â 1 : D√©clenchement 500 pixels AVANT d'atteindre le bas de la page
    rootMargin: '0px 0px 500px 0px', 
    
    // MODIFICATION CL√â 2 : D√©clenchement d√®s qu'un minuscule fragment de la carte est visible (plus fiable)
    threshold: 0.001 
});

    // 5. Lancement de l'observation
    console.log("[OBSERVER] Observation d√©marr√©e sur la derni√®re carte.");
    observer.observe(lastVideoCard);
        }
    // =======================================================
// 5. GESTION DES CLICS SUR LES VID√âOS (LIKES, COMMENTAIRES, CRUD)
// =======================================================

// --- FONCTIONS UTILITAIRES POUR LA SECTION COMMENTAIRES ---

function createCommentInputAndCloseHtml(videoId) {
    return `
        <div class="comment-input-area">
            <textarea id="comment-input-${videoId}" 
                      placeholder="√âcrire un commentaire..." 
                      maxlength="500"></textarea>
            <button class="submit-comment action-btn" data-video-id="${videoId}">
                <i class="fa-solid fa-paper-plane"></i>
            </button>
        </div>
    `;
}

// Fonction qui g√®re la fermeture fluide de la section commentaires
function closeCommentsSection(videoId) {
    const videoCard = document.querySelector(`.video-card[data-video-id="${videoId}"]`);
    const section = document.getElementById(`comments-section-${videoId}`);

    if (videoCard && section && videoCard.classList.contains('comments-open')) {
        // 1. D√©clenche la transition de glissement vers le bas (transform: translateY(100%))
        videoCard.classList.remove('comments-open'); 

        // 2. Attend que la transition soit finie (300ms comme dans le CSS)
        setTimeout(() => {
            // 3. Masque la section
            section.style.display = 'none';
        }, 300); // Doit correspondre √† la transition-duration du CSS (.comments-section)
    }
}

// Fonction qui construit la zone de saisie du nouveau commentaire
function createCommentSectionContent(comments, videoId) {
    const closeBtnHtml = `<button class="close-comments-btn action-btn" data-video-id="${videoId}"><i class="fa-solid fa-xmark"></i></button>`;
    const inputArea = createCommentInputAndCloseHtml(videoId);

    // üî• Structure optimis√©e pour le scroll infini
    return `
        <div class="comments-content-wrapper"> 
            ${closeBtnHtml} 
            <div class="existing-comments" data-video-id="${videoId}">
                <!-- Les commentaires seront ins√©r√©s ici -->
                <div class="comments-loading" style="display:none;">
                    <p>‚è≥ Chargement...</p>
                </div>
            </div>
        </div>
        ${inputArea}
    `;
}


// ‚úÖ 3. Fonction pour charger les commentaires (pagination backend)
function loadComments(videoId, page = 0, append = false) {
    const state = commentsPagination.get(videoId) || { page: -1, hasMore: true, loading: false };
    
    // √âviter les chargements simultan√©s
    if (state.loading || !state.hasMore) {
        console.log(`‚è∏Ô∏è Chargement ignor√© pour vid√©o ${videoId} (loading=${state.loading}, hasMore=${state.hasMore})`);
        return Promise.resolve();
    }
    
    // Mise √† jour de l'√©tat
    state.loading = true;
    commentsPagination.set(videoId, state);
    
    // Afficher le loader
    const loader = document.querySelector(`#comments-section-${videoId} .comments-loading`);
    if (loader) loader.style.display = 'block';
    
    console.log(`üì• Chargement commentaires - Vid√©o: ${videoId}, Page: ${page}`);
    
    return fetch(`/api/videos/${videoId}/comments?page=${page}&size=10`)
        .then(res => {
            if (!res.ok) throw new Error(`Erreur HTTP ${res.status}`);
            return res.json();
        })
        .then(apiResponse => {
            if (!apiResponse.success || !apiResponse.data) {
                throw new Error("Format API invalide");
            }
            
            const commentsData = apiResponse.data;
            const commentsArray = commentsData.comments || [];
            const totalCount = commentsData.totalCount || 0;
            
            console.log(`‚úÖ Re√ßu ${commentsArray.length} commentaires (total: ${totalCount})`);
            
            // Mise √† jour du compteur
            const countSpan = document.getElementById(`comment-count-span-${videoId}`);
            if (countSpan) countSpan.textContent = totalCount;
            
            // Trouver le conteneur
            const container = document.querySelector(`#comments-section-${videoId} .existing-comments`);
            
            if (container) {
                if (!append) {
                    // Premier chargement : vider le conteneur (sauf le loader)
                    const loader = container.querySelector('.comments-loading');
                    container.innerHTML = '';
                    if (loader) container.appendChild(loader);
                }
                
                // Ins√©rer les nouveaux commentaires
                const commentsHtml = commentsArray.map(c => createCommentElement(c)).join('');
                const loader = container.querySelector('.comments-loading');
                
                if (loader) {
                    // üî• IMPORTANT : Ajouter AVANT le loader (scroll vers le haut)
                    loader.insertAdjacentHTML('afterend', commentsHtml);
                } else {
                    container.insertAdjacentHTML('beforeend', commentsHtml);
                }
                
                // Scroll en bas (seulement pour le premier chargement)
                if (!append) {
                    setTimeout(() => {
                        container.scrollTop = container.scrollHeight;
                    }, 100);
                }
            }
            
            // Mise √† jour de l'√©tat de pagination
            state.page = page;
            state.hasMore = commentsArray.length === 10; // S'il y a 10 r√©sultats, il y en a peut-√™tre plus
            state.loading = false;
            commentsPagination.set(videoId, state);
            
            console.log(`üìä √âtat pagination vid√©o ${videoId}:`, state);
            
        })
        .catch(error => {
            console.error(`‚ùå Erreur chargement commentaires:`, error);
            state.loading = false;
            state.hasMore = false;
            commentsPagination.set(videoId, state);
        })
        .finally(() => {
            // Masquer le loader
            if (loader) loader.style.display = 'none';
        });
}

// ‚úÖ 4. Observer le scroll pour charger automatiquement
function setupCommentsScrollObserver(videoId) {
    const container = document.querySelector(`#comments-section-${videoId} .existing-comments`);
    
    if (!container) {
        console.warn(`‚ö†Ô∏è Conteneur de commentaires introuvable pour vid√©o ${videoId}`);
        return;
    }
    
    // √âviter les observers multiples
    if (container.dataset.scrollObserver === 'true') {
        console.log(`‚úÖ Observer d√©j√† actif pour vid√©o ${videoId}`);
        return;
    }
    
    container.dataset.scrollObserver = 'true';
    
    container.addEventListener('scroll', () => {
        const state = commentsPagination.get(videoId);
        
        if (!state || state.loading || !state.hasMore) return;
        
        // D√©tecter si on est proche du haut (scroll infini invers√©)
        const scrollTop = container.scrollTop;
        const triggerPoint = 200; // Charger 200px avant d'atteindre le haut
        
        if (scrollTop < triggerPoint) {
            console.log(`üîÑ Scroll d√©tect√© - Chargement page ${state.page + 1}`);
            
            // Sauvegarder la position de scroll actuelle
            const oldScrollHeight = container.scrollHeight;
            
            loadComments(videoId, state.page + 1, true).then(() => {
                // Restaurer la position relative apr√®s ajout
                const newScrollHeight = container.scrollHeight;
                container.scrollTop = newScrollHeight - oldScrollHeight + scrollTop;
            });
        }
    });
    
    console.log(`üëÄ Observer de scroll activ√© pour vid√©o ${videoId}`);
}

// --- GESTION DES CLICS GLOBALE ---
document.querySelector('#video-container').addEventListener('click', function(event){
        const videoCard = event.target.closest('.video-card');
        if(!videoCard) return;

    // Logique de suppression de vid√©o (DELETE)
    const deleteBtn = event.target.closest('.delete-video-btn');
    if(deleteBtn){
        const videoId = deleteBtn.dataset.videoId;
        // Remplacer par un modal UI personnalis√© pour √©viter window.confirm
        if(!confirm("√ätes-vous s√ªr de vouloir supprimer d√©finitivement cette vid√©o et tous ses commentaires/likes ?")) return; 
        fetch(`/api/videos/${videoId}`, { method: "DELETE", headers: getAuthHeaders('text/plain') })

        .then(res => {
            if (res.ok || res.redirected) {
                videoCard.remove();
            } else {
                res.json().then(data => alert(`Erreur de suppression de vid√©o: ${data.error}`)).catch(()=>alert("Erreur inconnue lors de la suppression."));
            }
        })
        .catch(console.error);
        return;
    }

    // Logique de suppression de commentaire (DELETE)
    const deleteCommentBtn = event.target.closest('.delete-comment-btn');
    if(deleteCommentBtn){
        const btn = deleteCommentBtn;
        const commentId = btn.dataset.commentId;
        // Remplacer par un modal UI personnalis√© pour √©viter window.confirm
        if(!confirm("√ätes-vous s√ªr de vouloir supprimer ce commentaire ?")) return;

       fetch(`/api/comments/${commentId}`, { method: "DELETE", headers: getAuthHeaders('text/plain') })

       .then(res => {
            if(res.ok) {
                const commentElement = btn.closest('.comment');
                
                const videoCard = btn.closest('.video-card'); 
                
                if(commentElement && videoCard) {
                    const videoId = videoCard.dataset.videoId;
                    commentElement.remove();

                    // D√©cr√©mentation locale du compteur
                    const countSpan = document.getElementById(`comment-count-span-${videoId}`);
                    if (countSpan) { countSpan.textContent = Math.max(0, (parseInt(countSpan.textContent) || 0) - 1); }
                
                } else if (commentElement) {
                    commentElement.remove();
                }
            } else { 
                // Gestion de l'erreur du serveur si res.ok est false
                res.json().then(data => alert(`Erreur de suppression de commentaire: ${data.error}`)).catch(()=>alert("Erreur inconnue lors de la suppression."));
            }
       })
       .catch(console.error);
       return;
    }

    // Logique d'√©dition/mise √† jour de commentaire (PUT)
    const editCommentBtn = event.target.closest('.edit-comment-btn');
    if (editCommentBtn) {
        const btn = editCommentBtn;
        const commentElement = btn.closest('.comment');
        const contentParagraph = commentElement ? commentElement.querySelector('.comment-content') : null;
        
        if (!commentElement || !contentParagraph) return;
        
        // Mode ENREGISTREMENT (si on est en mode 'editing')
        if (commentElement.classList.contains('editing')) {
            const textarea = commentElement.querySelector('textarea.edit-comment-input');
            const newContent = textarea ? textarea.value.trim() : null;
            const commentId = btn.dataset.commentId;

            if (!newContent) {
                alert("Le commentaire ne peut pas √™tre vide."); // Remplacer par un modal
                return;
            }

            // R√©cup√©ration du contenu original stock√©
            const originalContent = contentParagraph.dataset.originalContent || '';

            if (newContent === originalContent) {
                 // Pas de changement, annuler l'√©dition
                commentElement.classList.remove('editing');
                contentParagraph.textContent = originalContent; 
                delete contentParagraph.dataset.originalContent;
                // R√©tablit l'ic√¥ne
                btn.querySelector('i').classList.remove('fa-save');
                btn.querySelector('i').classList.add('fa-pen');
                // Supprime le bouton d'annulation
                commentElement.querySelector('.cancel-edit-btn')?.remove();
                return;
            }
            
            // Envoi de la requ√™te PUT
           fetch(`/api/comments/${commentId}`, { 
    method: "PUT", 
    headers: getAuthHeaders(), 
    body: JSON.stringify({ content: newContent }) 
})

            .then(res => {
                if (!res.ok) throw new Error("√âchec de la mise √† jour du commentaire.");
                return res.json();
            })
            .then(() => {
                // La mise √† jour du DOM pour tous se fera via WebSocket (handleUpdatedComment)
                console.log("Commentaire mis √† jour. Notification WebSocket envoy√©e.");
            })
            .catch(error => { 
                console.error(error); 
                alert(`Erreur de mise √† jour: ${error.message}`); // Remplacer par un modal
            });
            
            // Quitte le mode √©dition imm√©diatement pour le feedback UI
            commentElement.classList.remove('editing');
            delete contentParagraph.dataset.originalContent;
            // R√©tablit l'ic√¥ne de stylo
            btn.querySelector('i').classList.remove('fa-save');
            btn.querySelector('i').classList.add('fa-pen');
            // Supprime le bouton d'annulation
            commentElement.querySelector('.cancel-edit-btn')?.remove();
            
            return;
        } 
        // Mode √âDITION (si on n'est PAS en mode 'editing')
        else {
            // Optionnel : D√©sactiver l'√©dition des autres commentaires
            // (Laisser comme √ßa pour l'instant pour la simplicit√©)

            commentElement.classList.add('editing');
            
            const currentContent = contentParagraph.textContent.trim();
            const textareaHtml = `<textarea class="edit-comment-input" maxlength="500">${currentContent}</textarea>`; 
            
            // Sauvegarde de l'ancien contenu dans un attribut de donn√©es du paragraphe (pour l'annulation)
            contentParagraph.dataset.originalContent = currentContent;
            
            // Remplacer le contenu par la zone de texte
            contentParagraph.innerHTML = textareaHtml; 
            
            // Changer l'ic√¥ne en enregistrement
            btn.querySelector('i').classList.remove('fa-pen');
            btn.querySelector('i').classList.add('fa-save'); 
            
            // Ajouter un bouton d'annulation temporaire
            const cancelBtnHtml = `<button class="cancel-edit-btn action-btn" data-comment-id="${btn.dataset.commentId}" type="button"><i class="fa-solid fa-xmark"></i></button>`;
            
            // Ins√®re le bouton seulement s'il n'existe pas d√©j√†
            if (!commentElement.querySelector('.cancel-edit-btn')) {
                btn.parentElement.insertAdjacentHTML('beforeend', cancelBtnHtml);
            } 
            
            // Focus sur la zone de texte
            const textarea = commentElement.querySelector('textarea.edit-comment-input');
            if(textarea) {
                textarea.focus();
                textarea.select(); 
            }
        }
        return;
    }
    
    // Logique d'annulation d'√©dition de commentaire
    const cancelEditBtn = event.target.closest('.cancel-edit-btn');
    if (cancelEditBtn) {
        const commentElement = cancelEditBtn.closest('.comment');
        const contentParagraph = commentElement.querySelector('.comment-content');
        const editBtn = commentElement.querySelector('.edit-comment-btn');
        
        // Restaure le contenu original
        if (contentParagraph && contentParagraph.dataset.originalContent) {
             contentParagraph.textContent = contentParagraph.dataset.originalContent;
             delete contentParagraph.dataset.originalContent; // Nettoyage
        }
        
        commentElement.classList.remove('editing');
        
        // R√©tablit l'ic√¥ne
        if (editBtn) {
            editBtn.querySelector('i').classList.remove('fa-save');
            editBtn.querySelector('i').classList.add('fa-pen');
        }
        // Supprime le bouton d'annulation
        cancelEditBtn.remove();
        return;
    }

        // ========================================
    // üî• AJOUT : LOGIQUE DE LIKE (d√©placer depuis le 2e √©couteur)
    // ========================================
   /* const likeBtn = event.target.closest('.like-btn');
    if (likeBtn) {
        const videoId = likeBtn.dataset.videoId;
        
        const span = document.getElementById('likes-count-' + videoId);
        const icon = likeBtn.querySelector('i');

        const isCurrentlyLiked = icon.classList.contains('fa-solid');
        let currentLikes = parseInt(span.textContent) || 0;

        const savedIconClasses = icon.className;
        const savedLikesText = span.textContent;
        
        if (isCurrentlyLiked) {
            icon.classList.remove('fa-solid'); icon.classList.add('fa-regular');
            span.textContent = Math.max(0, currentLikes - 1);
        } else {
            icon.classList.remove('fa-regular'); icon.classList.add('fa-solid');
            span.textContent = currentLikes + 1;
        }

        fetch(`/api/videos/${videoId}/like`, {
        method: "POST",
        headers: getAuthHeaders()
    })
        .then(res => {
            if (!res.ok) {
                icon.className = savedIconClasses;
                span.textContent = savedLikesText;
                throw new Error("Action √©chou√©e, code: " + res.status); 
            }
            return res.json();
        })
        .then(data => {
            span.textContent = `${data.data}`;
            
            if (data.data > currentLikes) {
                icon.classList.remove('fa-regular'); icon.classList.add('fa-solid');
            } else {
                icon.classList.remove('fa-solid'); icon.classList.add('fa-regular');
            }
        })
        .catch(error => {
            console.error(`Erreur like pour Vid√©o ${videoId}:`, error);
        });
        return;
    }*/

    // ========================================
    // üî• AJOUT : ENVOI DE COMMENTAIRE (d√©placer depuis le 2e √©couteur)
    // ========================================
 const submitCommentBtn = event.target.closest('.submit-comment');
if(submitCommentBtn){
    const videoId = submitCommentBtn.dataset.videoId;
    const input = document.querySelector(`#comment-input-${videoId}`);
    const content = input.value.trim();
    
    if(!content) return;

  fetch(`/api/videos/${videoId}/comment`, { 
    method: 'POST', 
    headers: getAuthHeaders(), 
    body: JSON.stringify({ content }) 
})
    .then(res => { 
        if (!res.ok) throw new Error("√âchec de l'envoi du commentaire."); 
        return res.json();
    })
    .then(data => {
        input.value = '';

        // ‚úÖ Chercher directement .existing-comments
        const container = document.querySelector(`#comments-section-${videoId} .existing-comments`);
        
        if (container) {
            const loader = container.querySelector('.comments-loading');
            const newCommentHtml = createCommentElement(data.comment);
            
            if (loader) {
                loader.insertAdjacentHTML('beforebegin', newCommentHtml);
            } else {
                container.insertAdjacentHTML('beforeend', newCommentHtml);
            }
            
            container.scrollTop = container.scrollHeight;
            console.log(`‚úÖ Commentaire ajout√© au DOM pour vid√©o ${videoId}`);
        }

        // ‚úÖ Mise √† jour du compteur (TOUJOURS)
        const countSpan = document.getElementById(`comment-count-span-${videoId}`);
        if (countSpan) {
            const currentCount = parseInt(countSpan.textContent || 0);
            countSpan.textContent = currentCount + 1;
            console.log(`‚úÖ Compteur mis √† jour: ${currentCount} ‚Üí ${currentCount + 1}`);
        }
    })
    .catch(error => { 
        console.error(`‚ùå √âchec lors de l'envoi du commentaire: ${error.message}`); 
    });
    
    return;
}
    
    // LOGIQUE D'OUVERTURE/FERMETURE DES COMMENTAIRES
    const commentToggleBtn = event.target.closest('.comment-btn'); 
    const closeBtn = event.target.closest('.close-comments-btn'); 

    // 1. G√©rer la fermeture (bouton 'X')
    if (closeBtn) { 
        const videoId = closeBtn.dataset.videoId;
        closeCommentsSection(videoId); // Utilisation de la nouvelle fonction pour la transition fluide
        return; 
    }
// 2. G√©rer l'ouverture (bouton 'üí¨ commentaires')
if (commentToggleBtn) {
    const videoId = commentToggleBtn.dataset.videoId;
    const section = document.getElementById('comments-section-' + videoId);
    
    // Si d√©j√† affich√©e, on ferme (logique de toggle)
    if (videoCard.classList.contains('comments-open')) {
          closeCommentsSection(videoId);
          return;
    }

    // --- LOGIQUE D'OUVERTURE ET DE CHARGEMENT ---
    
    // Assure que display: block est l√† AVANT d'ajouter comments-open pour d√©clencher la transition
    section.style.display = 'block';
    section.offsetHeight; // <-- Ceci est la ligne de correction
    
    // D√©clenche la transition CSS (transform: translateY(0))
    videoCard.classList.add('comments-open'); 
    section.innerHTML = createCommentSectionContent([], videoId);
    commentsPagination.set(videoId, { page: -1, hasMore: true, loading: false });
    
    loadComments(videoId, 0, false).then(() => {
        setupCommentsScrollObserver(videoId);
    });
    
    return; // <-- L'accolade de fermeture du 'if (commentToggleBtn)' est ici
    
}
});

/**
 * G√®re le like/unlike d'une vid√©o avec mise √† jour optimiste de l'UI
 * @param {number} videoId - L'ID de la vid√©o √† liker
 */
function likeVideo(videoId) {
    const heartIcon = document.getElementById('like-icon-svg-' + videoId);
    const counter = document.getElementById('likes-count-span-' + videoId);
    
    if (!heartIcon || !counter) {
        console.error(`‚ùå √âl√©ments non trouv√©s pour la vid√©o ${videoId}`);
        return;
    }
    
    // 1. üé® Mise √† jour INSTANTAN√âE de l'UI (optimiste)
    const wasLiked = heartIcon.classList.contains('liked');
    heartIcon.classList.toggle('liked');
    
    let currentCount = parseInt(counter.textContent) || 0;
    const newOptimisticCount = wasLiked ? currentCount - 1 : currentCount + 1;
    counter.textContent = newOptimisticCount;
    
    console.log(`üîÑ [Optimiste] Like ${wasLiked ? 'retir√©' : 'ajout√©'} pour vid√©o ${videoId}`);
    
    // 2. üì° Envoi de la requ√™te au backend
   fetch(`/api/videos/${videoId}/like`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            // ‚úÖ Token CSRF requis par Spring Security
            [csrfHeader]: csrfToken
        },
        credentials: 'same-origin'
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Erreur HTTP: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.success && data.data !== null && data.data !== undefined) {
            // ‚úÖ Confirmation : synchroniser avec la valeur EXACTE du serveur
            counter.textContent = data.data;
            console.log(`‚úÖ [REST] Confirmation serveur: ${data.data} likes`);
        } else {
            console.warn('‚ö†Ô∏è R√©ponse inattendue du serveur:', data);
            // Rollback en cas d'erreur
            heartIcon.classList.toggle('liked');
            counter.textContent = currentCount;
        }
    })
    .catch(error => {
        console.error('‚ùå Erreur lors du like:', error);
        
        // üîÑ Rollback de l'UI en cas d'erreur r√©seau
        heartIcon.classList.toggle('liked');
        counter.textContent = currentCount;
        
        alert('Impossible de liker la vid√©o. Veuillez r√©essayer.');
    });
}
        // 6. WEBSOCKETS (STOMP/SockJS) - MODIFI√â POUR LE SCOPING PAR VID√âO
       
// === NOUVEAU : gestion des batches de commentaires ===
function handleNewCommentsBatch(payload) {
    const messages = Array.isArray(payload) ? payload : [payload];
    const videoId = messages[0]?.videoId;
    
    // üîç DEBUG 1
    console.log(`üîî WebSocket re√ßu pour vid√©o ${videoId}:`, messages);
    
    const existingCommentsContainer = document.querySelector(`#comments-section-${videoId} .existing-comments`);
    const countSpan = document.getElementById(`comment-count-span-${videoId}`);

    // üîç DEBUG 2
    console.log(`üì¶ Conteneur trouv√©:`, existingCommentsContainer ? 'OUI ‚úÖ' : 'NON ‚ùå');
    console.log(`üî¢ Compteur trouv√©:`, countSpan ? `OUI (${countSpan.textContent})` : 'NON ‚ùå');

    let newCommentCount = 0;

    messages.forEach(message => {
        const commentDto = message.comment; 
        
        if (message.action === "CREATED" && commentDto) {
            const commentId = commentDto.commentId || commentDto.id;
            
            // üîç DEBUG 3
            console.log(`‚ûï Tentative d'ajout du commentaire ${commentId}`);
            
            const existingComment = document.querySelector(`.comment[data-comment-id="${commentId}"]`);
            
            if (existingComment) {
                console.log(`‚ö†Ô∏è Commentaire ${commentId} d√©j√† pr√©sent, skip.`);
                return;
            }
            
            if (existingCommentsContainer) {
                const newCommentHtml = createCommentElement(commentDto);
                existingCommentsContainer.insertAdjacentHTML('beforeend', newCommentHtml);
                
                // üîç DEBUG 4
                console.log(`‚úÖ Commentaire ${commentId} ajout√© au DOM`);
            } else {
                // üîç DEBUG 5
                console.error(`‚ùå PROBL√àME: Le conteneur .existing-comments n'existe pas !`);
            }
            newCommentCount++;
        }
    });

    if (existingCommentsContainer) {
        existingCommentsContainer.scrollTop = existingCommentsContainer.scrollHeight;
    }

   
}



       function handleDeletedComment(payload) {
    if (payload.action === "DELETED") {
        const commentElement = document.querySelector(`.comment[data-comment-id="${payload.commentId}"]`);
        if (commentElement) commentElement.remove();

        // ‚úÖ Toujours utiliser le compteur exact envoy√© par le backend
        const countSpan = document.getElementById(`comment-count-span-${payload.videoId}`);
        if (countSpan && payload.newCommentsCount !== undefined) {
            countSpan.textContent = payload.newCommentsCount;
        }
            }
        }
      function handleUpdatedComment(payload) {
    if (payload.action === "UPDATED") {
        // üéØ R√©cup√®re le DTO complet
        const updatedCommentDto = payload.comment; 
        
        if (!updatedCommentDto) return;

        const commentElement = document.querySelector(`.comment[data-comment-id="${updatedCommentDto.id}"]`);
        
        if (commentElement) {
            // Remplacer l'ancien √©l√©ment par le nouvel √©l√©ment HTML g√©n√©r√© par le DTO mis √† jour
            // Cela g√®re automatiquement la mise √† jour du contenu et de la date.
            commentElement.outerHTML = createCommentElement(updatedCommentDto);
        }
        
        // Note: Vous n'avez plus besoin de retirer la classe 'editing' ici, car l'√©l√©ment
        // entier est remplac√© et le formulaire d'√©dition dispara√Æt si l'utilisateur l'avait.
    }
}
  function handleVideoStatsUpdate(videoId, statsPayload) {
    const { newLikesCount, newCommentsCount } = statsPayload;

    console.log(`[WS] update video ${videoId}: likes=${newLikesCount}, comments=${newCommentsCount}`);

    function safeUpdate(idSuffix, value, videoId, retries = 20) {
        const el = document.getElementById(idSuffix + videoId);
        if (el) {
            el.textContent = value;
        } else if (retries > 0) {
            setTimeout(() => safeUpdate(idSuffix, value, videoId, retries - 1), 50);
        } else {
            console.warn(`Impossible de mettre √† jour ${idSuffix}${videoId}, √©l√©ment non trouv√©`);
        }
    }

    if (newLikesCount != null) safeUpdate('likes-count-span-', newLikesCount, videoId);
    if (newCommentsCount != null) safeUpdate('comment-count-span-', newCommentsCount, videoId);
}

    // =======================================================
// GESTION INTELLIGENTE DES ABONNEMENTS WEBSOCKET (CORRIG√â)
// =======================================================

function subscribeToNewVideos() {
if (!stompClient || !stompClient.connected) {
 console.warn("STOMP client not connected, skipping dynamic subscription.");
return;
 }
 
 const videoCards = document.querySelectorAll('.video-card');

 videoCards.forEach(card => {
 const videoId = card.dataset.videoId;
 
 // Si d√©j√† abonn√©, on ignore
 if (!videoId || activeSubscriptions.has(videoId)) return;
 
 const subscriptions = [];
console.log("üîó Tentative d'abonnement √† :", `/topic/videos/${videoId}/comments`);
 subscriptions.push(
 stompClient.subscribe('/topic/videos/' + videoId + '/comments', function (message) {
const payload = JSON.parse(message.body);

 if (payload.comment && payload.comment.authorUsername === currentUsername) {
 console.log("üë§ C'est mon propre commentaire ‚Äî affichage instantan√© d√©j√† fait ?");
 // on laisse passer si le DOM ne contient pas d√©j√† ce commentaire
 const existingComment = document.querySelector(`.comment[data-comment-id="${payload.comment.id}"]`);
 if (existingComment) {
 console.log("‚úÖ D√©j√† visible, on ignore le doublon.");
return;
 }
 console.log("üÜï Mon commentaire n'est pas encore dans le DOM, on l'ajoute quand m√™me.");
}

 
 handleNewCommentsBatch(payload);
 })
);
 
// ‚ùå ANCIEN BLOC DE SUPPRESSION RETIR√â. 
// La suppression est maintenant g√©r√©e par l'abonnement global /topic/feed/video-deleted dans connectToStomp().
// La fonction handleDeletedComment g√®re toujours la suppression de commentaires, qui peut √™tre re√ßue
// via un autre topic si vous l'avez pr√©vu (comme un topic d√©di√© aux commentaires).
// Mais l'abonnement sp√©cifique √† la suppression de VID√âO est retir√© d'ici.

 subscriptions.push(
 stompClient.subscribe('/topic/videos/' + videoId + '/update', function (message) {
handleUpdatedComment(JSON.parse(message.body));
 })
 );

subscriptions.push(
stompClient.subscribe('/topic/video/' + videoId, function (message) {
 try {
 // üéØ √âTAPE CRUCIALE : D√©coder le JSON VideoStatsUpdateDto
 const statsPayload = JSON.parse(message.body);

 // üéØ Appel de la fonction de mise √† jour pour g√©rer le compteur et l'√©tat
 handleVideoStatsUpdate(videoId, statsPayload);

 console.log(`[Stats Update] Vid√©o ${videoId} mise √† jour:`, statsPayload);

 } catch (e) {
 console.error("Erreur de parsing du payload stats:", e, message.body);
 }
 })
);

 // Stocker les abonnements pour cette vid√©o
 activeSubscriptions.set(videoId, subscriptions);
console.log(`‚úÖ Abonn√© √† la vid√©o ${videoId}`);
 });
 
 // üî• AJOUT CRITIQUE : Nettoyer les abonnements invisibles
 cleanupInvisibleSubscriptions();
}

// üî• NOUVELLE FONCTION : D√©sabonner les vid√©os hors √©cran
function cleanupInvisibleSubscriptions() {
    const visibleIds = new Set();
    const cards = document.querySelectorAll('.video-card');
    
    // Identifier les vid√©os visibles + buffer de 5 suivantes
    cards.forEach((card, index) => {
        const rect = card.getBoundingClientRect();
        const isInViewport = rect.top < window.innerHeight + 1000 && rect.bottom > -1000;
        
        if (isInViewport || index < 5) {
            visibleIds.add(card.dataset.videoId);
        }
    });
    
    // D√©sabonner les vid√©os qui ne sont plus visibles
    activeSubscriptions.forEach((subscriptions, videoId) => {
        if (!visibleIds.has(videoId)) {
            // D√©sabonner tous les topics de cette vid√©o
            subscriptions.forEach(sub => sub.unsubscribe());
            activeSubscriptions.delete(videoId);
            console.log(`‚ùå D√©sabonn√© de la vid√©o ${videoId}`);
        }
    });
    
    console.log(`üìä Abonnements WebSocket actifs: ${activeSubscriptions.size}`);
}
        // 7. Lancement de la connexion et des Observateurs - FINALIS√â

// ‚ùå SUPPRIMER ENTI√àREMENT CES FONCTIONS OBSOL√àTES
/*
function debounce(func, delay) {
    let timeout;
    return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
    };
}
// SUPPRIMER CETTE VARIABLE OBSOL√àTE
const debouncedCheckVideosInView = debounce(checkVideosInView, 100);
*/ 
// =======================================================
// NETTOYAGE AUTOMATIQUE P√âRIODIQUE
// =======================================================
// Lancer un nettoyage automatique toutes les 5 secondes
setInterval(() => {
    if (stompClient && stompClient.connected) {
        cleanupInvisibleSubscriptions();
    }
    
    // Logs pour debug (vous pouvez retirer en production)
    console.log('üßπ Nettoyage automatique effectu√©');
    console.log(`üìä Vid√©os en DOM: ${document.querySelectorAll('.video-card').length}`);
    console.log(`üìä Abonnements WebSocket: ${activeSubscriptions.size}`);
}, 5000); // Toutes les 5 secondes

document.addEventListener('DOMContentLoaded', () => {

    // 1. Initialisation et Connexion STOMP
    const socket = new SockJS('/ws');
    stompClient = Stomp.over(socket);
    const headers = {};
    if (csrfHeader && csrfToken) {
        headers[csrfHeader] = csrfToken;
    }
    
    // Fonction de connexion/reconnexion
    const connectToStomp = () => {
        stompClient.connect(headers, function (frame) {
            console.log('WebSocket Connected: ' + frame);
            
            // üöÄ NOUVEL ABONNEMENT CRITIQUE : Suppression globale de vid√©o
            stompClient.subscribe('/topic/feed/video-deleted', function (message) {
                try {
                    const data = JSON.parse(message.body);
                    if (data.videoId) {
                        // Appel de la fonction utilitaire cr√©√©e pr√©c√©demment
                        removeVideoCardFromDOM(data.videoId); 
                    }
                } catch (e) {
                    console.error("Erreur de traitement du message de suppression:", e);
                }
            });
            
            // üéØ Appel pour abonner les vid√©os initiales de la page
            subscribeToNewVideos();

        }, function(error) {
            console.error('STOMP Connection Error:', error);
            // Tente de se reconnecter apr√®s 5 secondes
            setTimeout(connectToStomp, 5000);
        });
    }; // Fin de la fonction connectToStomp
    
    // 2. Appel initial pour lancer la connexion STOMP
    connectToStomp(); 

}); // <--- CORRECTION : Fermeture du document.addEventListener('DOMContentLoaded', ...



// TODO: Ajouter TOUTES les autres fonctions de video-feed.html ici
// (Pour √©viter de d√©passer la limite, je te recommande de copier-coller 
// tout le bloc <script> de video-feed.html dans ce fichier)

console.log('‚úÖ Page HOME simplifi√©e charg√©e avec syst√®me vid√©os');
</script>

</body>
</html>