<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="_csrf" th:content="${_csrf.token}"/>
    <meta name="_csrf_header" th:content="${_csrf.headerName}"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#000000"> <link rel="manifest" th:href="@{/manifest.json}">
    <link rel="apple-touch-icon" sizes="192x192" th:href="@{/assets/icons/icon-192.png}">
    <title>Feed Immersif - Football Family</title>
    
    <link rel="stylesheet" th:href="@{/css/style.css(v=${cssVersion})}">


    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <script th:src="@{/service-worker-register.js}" defer></script>
</head>
<body>

    <header>
        <div class="logo">Football Family</div>
    </header>

    <div id="video-container" th:insert="fragments/video-cards :: video-cards(${videos})"></div>

    <div id="loader" style="display: none;"><p>Chargement...</p></div>

    <div th:insert="fragments/navbar :: mobile-navbar"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.6.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <script th:inline="javascript">
    
        // =======================================================
        // 1. D√âCLARATION DES VARIABLES GLOBALES
        // =======================================================
        let currentPage = /*[[${currentPage}]]*/ 0;
        let category = /*[['' + ${category}]]*/ 'general';
        const currentUsername = /*[['' + ${#authentication.name != 'anonymousUser' ? #authentication.name : 'nab'} + '']]*/ 'nab';

        let loading = false;
        let hasMoreVideos = true;
        let observer;
        let isManuallyMuted = true; // Variable d'√©tat utilisateur pour le son
        let stompClient = null; // Client STOMP pour les WebSockets
        let videoObserver; // Ajoutez ceci aux variables globales
        const commentsPagination = new Map();
        const csrfToken = document.querySelector('meta[name="_csrf"]') ? document.querySelector('meta[name="_csrf"]').content : null;
        const csrfHeader = document.querySelector('meta[name="_csrf_header"]') ? document.querySelector('meta[name="_csrf_header"]').content : null;
        // =======================================================
        // AJOUT : Utilit√© de l'ic√¥ne de Mute
        // =======================================================
        function updateMuteIcon(buttonElement, isMuted) {
            const icon = buttonElement ? buttonElement.querySelector('i') : null;
            if (icon) {
                if (isMuted) {
                    icon.classList.remove('fa-volume-high');
                    icon.classList.add('fa-volume-xmark'); // Ic√¥ne barr√©e
                } else {
                    icon.classList.remove('fa-volume-xmark');
                    icon.classList.add('fa-volume-high'); // Ic√¥ne normale
                }
            }
        }


        function getAuthHeaders(contentType = 'application/json') {
            const headers = { 'Content-Type': contentType };
            if (csrfHeader && csrfToken) {
                headers[csrfHeader] = csrfToken;
            }
            return headers;
        }
        // =======================================================
        // AJOUT : Correction JS pour forcer la mise en page Flexbox (mobile)
        // =======================================================
        function fixVideoTitlePosition() {
            // Cibler tous les titres √† l'int√©rieur de l'overlay des cartes vid√©o
            const videoTitles = document.querySelectorAll('.video-card .overlay .video-title');

            videoTitles.forEach(title => {
                // Appliquer un d√©lai pour s'assurer de s'ex√©cuter apr√®s le script fautif
                setTimeout(() => {
                    // Surcharge le style inline (qui est prioritaire sur le CSS !important)
                    if (window.innerWidth <= 1023) {
                        title.style.position = 'relative';
                        title.style.bottom = 'unset';
                        title.style.left = 'unset';
                        title.style.width = '100%';
                        // Retirer la propri√©t√© 'float' au cas o√π elle aurait √©t√© inject√©e
                        title.style.float = 'none';
                    }
                }, 150); // D√©lai augment√© √† 150ms pour plus de s√©curit√©
            });
        }

 function createCommentElement(comment) {
    const commentId = comment.commentId || comment.id;
    
    // ‚úÖ CORRECTION 1 : Rendre le nom d'auteur robuste
    // 1. Cherche `authorUsername` (DTO), 2. Cherche `author.username` (si l'objet est complet), 3. Sinon 'Anonymous'
    const authorName = comment.authorUsername 
                     || (comment.author ? comment.author.username : 'Anonymous');
    
    // ‚úÖ CORRECTION 2 : Rendre le contenu robuste (pour √©viter 'undefined')
    const content = comment.content || 'Contenu non disponible';

    const isOwner = authorName === currentUsername;

    // ‚úÖ CORRECTION 3 : Rendre la date robuste (pour g√©rer 'Invalid Date')
    let dateString = 'Date Invalide';
    if (comment.createdAt) {
        try {
            let dateObject = new Date(comment.createdAt); 
            
            // Si le format direct √©choue, nettoie la cha√Æne (retire les microsecondes excessives)
            if (isNaN(dateObject.getTime())) { 
                // Regex pour couper apr√®s la 3√®me d√©cimale (milli-secondes) et ajouter Z (pour UTC)
                const cleanedDateString = comment.createdAt.replace(/(\.\d{3})\d+/, '$1Z');
                dateObject = new Date(cleanedDateString);
            }
            
            if (!isNaN(dateObject.getTime())) {
                dateString = dateObject.toLocaleTimeString('fr-FR', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
            }
        } catch (e) {
            console.error("Erreur lors du formatage de la date:", e);
        }
    }


    const actionsHtml = isOwner ? `
        <div class="comment-actions">
            <button class="edit-comment-btn" data-comment-id="${commentId}"><i class="fa-solid fa-pen"></i></button>
            <button class="delete-comment-btn" data-comment-id="${commentId}"><i class="fa-solid fa-trash"></i></button>
        </div>
    ` : '';

    return `
        <div class="comment" data-comment-id="${commentId}">
            <div class="comment-header">
                <i class="fa-solid fa-user"></i>
                <span class="comment-username">${authorName}</span>
                <span class="comment-date">${dateString}</span>
                ${actionsHtml}
            </div>
            <p class="comment-content">${content}</p>
        </div>
    `;
}
        // =======================================================
        // 3. GESTION DE LA LECTURE VID√âO (AUTO-PLAY IMMERSIF) - CORRECTION FINALE
        // =======================================================
        function setupMuteToggles() {
            const muteButtons = document.querySelectorAll('.toggle-mute-btn:not([data-mute-listener="true"])');

            muteButtons.forEach(btn => {

                btn.addEventListener('click', (e) => {
                    e.preventDefault();

                    const videoCard = btn.closest('.video-card');
                    const video = videoCard ? videoCard.querySelector('.video-element') : null;
                    
                    if (video) {
                        // INVERSION : ON INVERSE L'√âTAT GLOBAL AU CLIC
                        isManuallyMuted = !isManuallyMuted;
                        
                        // On applique le nouvel √©tat global √† la vid√©o
                        video.muted = isManuallyMuted;
                        
                        // Mettre √† jour l'ic√¥ne imm√©diatement
                        updateMuteIcon(btn, isManuallyMuted);
                        
                    }
                   
                });

                btn.setAttribute('data-mute-listener', 'true');
            });
        }
       // --- NOUVELLE LOGIQUE PLAY/PAUSE (IntersectionObserver pour la fluidit√©) ---
function setupVideoPlayObserver() {
    if (videoObserver) {
        videoObserver.disconnect();
    }
    
    // Seulement 75% est visible pour le comportement "TikTok"
    videoObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            const videoElement = entry.target.querySelector('.video-element');
            const muteBtn = entry.target.querySelector('.toggle-mute-btn');

            if (!videoElement) return;

            if (entry.intersectionRatio > 0.75) {
                // VID√âO PRINCIPALE : LECTURE
                videoElement.muted = isManuallyMuted;
                if (videoElement.paused) {
                    videoElement.play().catch(e => {
                        console.warn(`Lecture vid√©o bloqu√©e (Autoplay). For√ßage du mute.`, e.name);
                        videoElement.muted = true;
                        isManuallyMuted = true; // Mise √† jour de l'√©tat global
                        videoElement.play().catch(e => console.error("√âchec d√©finitif.", e.name));
                    });
                }
                if (muteBtn) updateMuteIcon(muteBtn, videoElement.muted);

            } else {
                // AUTRES VID√âOS : PAUSE et MUTE forc√©
                if (!videoElement.paused) {
                    videoElement.pause();
                }
                // Mute forc√© est essentiel pour ne pas consommer de ressources
                videoElement.muted = true;
                if (muteBtn) updateMuteIcon(muteBtn, true);
            }
        });
    }, {
        root: null, // Viewport
        threshold: 0.75 
    });

    // Observez toutes les cartes vid√©o pr√©sentes
    document.querySelectorAll('.video-card').forEach(card => {
        videoObserver.observe(card);
    });
}
        // =======================================================
        // 4. SCROLL INFINI : FONCTIONS
        // =======================================================
      function loadMoreVideos() {
    console.log(`[LOAD] Tentative de chargement de la page : ${currentPage + 1}.`);

    // AJOUTEZ CES ACCOLADES
    if (loading || !hasMoreVideos) {
        console.log("[LOAD] Chargement ignor√© (d√©j√† en cours ou fin du flux).");
        return; // Maintenant, ce return est conditionnel.
    }
    // FIN DE LA ZONE CRITIQUE

    loading = true;
    document.getElementById('loader').style.display = 'block';

    currentPage++;
            let url = `/videos/feed/fragment?page=${currentPage}`;
            if (category && category !== 'null' && category.trim() !== '') {
                url += `&category=${category}`;
            }

            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Erreur de chargement des fragments');
                    }
                    return response.text();
                })
               .then(html => {
    const videoContainer = document.getElementById('video-container');
    
    if (html.trim() === '') {
        hasMoreVideos = false;
        console.log("Fin du flux.");
        const endMessage = document.createElement('p');
        endMessage.textContent = "C'est tout ce que nous avons pour le moment !";
        videoContainer.appendChild(endMessage);
    } else {
        // üî• AJOUT CRITIQUE : Nettoyer AVANT d'ajouter de nouvelles vid√©os
        pruneOldVideos();
        
        videoContainer.insertAdjacentHTML('beforeend', html);
        console.log(`Page ${currentPage} charg√©e.`);
                        
                        // ESSENTIEL : LIE LES √âCOUTEURS DE MUTE/UNMUTE AUX NOUVELLES VID√âOS
                        setupMuteToggles();

                        // üéØ CORRECTION D'ALIGNEMENT POUR LES FRAGMENTS CHARG√âS
                        fixVideoTitlePosition();

                        // üöÄ ABONNEMENT AUX NOUVEAUX TOPICS (Likes & Commentaires)
                        subscribeToNewVideos();

                        setupVideoPlayObserver(); 

                        // Relance l'observation sur la nouvelle derni√®re carte
                        setupIntersectionObserver();
                    }
                })
                .catch(error => {
                    console.error("Erreur de chargement:", error);
                    hasMoreVideos = false;
                })
                .finally(() => {
                    loading = false;
                    document.getElementById('loader').style.display = 'none';
                });
        }

        // =======================================================
// VIRTUALISATION : LIMITER LE NOMBRE DE VID√âOS EN DOM
// =======================================================
function pruneOldVideos() {
    const MAX_VIDEOS_IN_DOM = 10; // Maximum de vid√©os dans le DOM
    const videoCards = document.querySelectorAll('.video-card');
    
    if (videoCards.length > MAX_VIDEOS_IN_DOM) {
        const toRemove = videoCards.length - MAX_VIDEOS_IN_DOM;
        
        console.log(`üóëÔ∏è Suppression de ${toRemove} anciennes vid√©os`);
        
        // Supprimer les vid√©os les plus anciennes (en haut)
        for (let i = 0; i < toRemove; i++) {
            const card = videoCards[i];
            const videoId = card.dataset.videoId;
            
            // 1. D√©sabonner des WebSockets
            const subscriptions = activeSubscriptions.get(videoId);
            if (subscriptions) {
                subscriptions.forEach(sub => sub.unsubscribe());
                activeSubscriptions.delete(videoId);
            }
            
            // 2. Arr√™ter et d√©truire la vid√©o
            const videoElement = card.querySelector('.video-element');
            if (videoElement) {
                videoElement.pause();
                videoElement.removeAttribute('src'); // Lib√®re le buffer
                videoElement.load();
            }
            
            // 3. Retirer du IntersectionObserver
            if (videoObserver) {
                videoObserver.unobserve(card);
            }
            
            // 4. Supprimer du DOM
            card.remove();
            
            console.log(`üóëÔ∏è Vid√©o ${videoId} supprim√©e du DOM`);
        }
    }
}

       function setupIntersectionObserver() {
    // 1. Utilisez une m√©thode de s√©lection plus robuste
    const allVideoCards = document.querySelectorAll('.video-card');
    
    // 2. S√©lectionnez le dernier √©l√©ment du NodeList (m√©thode la plus fiable)
    const lastVideoCard = allVideoCards.length > 0 ? allVideoCards[allVideoCards.length - 1] : null;

    // üí° LOGS DE DEBUG : D√©terminons ce qui se passe
    console.log("Nombre de cartes vid√©o trouv√©es :", allVideoCards.length); 

    // 3. D√©placement du message d'avertissement
    if (!lastVideoCard || !hasMoreVideos) {
        if (!lastVideoCard) {
            // Se d√©clenche UNIQUEMENT si aucune carte n'est trouv√©e (ce qui est le cas pour un √©chec)
            console.warn("[OBSERVER] Aucune carte vid√©o trouv√©e dans le DOM. Arr√™t de l'observation.");
        }
        return;
    }

    // Si on arrive ici, on a une carte et on doit l'observer.

    // D√©connexion de l'ancien observer (important pour la r√©initialisation apr√®s chargement)
    if (observer) {
        observer.disconnect();
    }

 observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
        if (entry.isIntersecting) {
            console.log("[OBSERVER] D√©clenchement de l'intersection !");
            observer.unobserve(entry.target);
            loadMoreVideos();
        }
    });
}, {
    root: null,
    // MODIFICATION CL√â 1 : D√©clenchement 500 pixels AVANT d'atteindre le bas de la page
    rootMargin: '0px 0px 500px 0px', 
    
    // MODIFICATION CL√â 2 : D√©clenchement d√®s qu'un minuscule fragment de la carte est visible (plus fiable)
    threshold: 0.001 
});

    // 5. Lancement de l'observation
    console.log("[OBSERVER] Observation d√©marr√©e sur la derni√®re carte.");
    observer.observe(lastVideoCard);
        }
    // =======================================================
// 5. GESTION DES CLICS SUR LES VID√âOS (LIKES, COMMENTAIRES, CRUD)
// =======================================================

// --- FONCTIONS UTILITAIRES POUR LA SECTION COMMENTAIRES ---

// Fonction qui g√®re la fermeture fluide de la section commentaires
function closeCommentsSection(videoId) {
    const videoCard = document.querySelector(`.video-card[data-video-id="${videoId}"]`);
    const section = document.getElementById(`comments-section-${videoId}`);

    if (videoCard && section && videoCard.classList.contains('comments-open')) {
        // 1. D√©clenche la transition de glissement vers le bas (transform: translateY(100%))
        videoCard.classList.remove('comments-open'); 

        // 2. Attend que la transition soit finie (300ms comme dans le CSS)
        setTimeout(() => {
            // 3. Masque la section
            section.style.display = 'none';
        }, 300); // Doit correspondre √† la transition-duration du CSS (.comments-section)
    }
}

// Fonction qui construit la zone de saisie du nouveau commentaire
function createCommentSectionContent(comments, videoId) {
    const closeBtnHtml = `<button class="close-comments-btn action-btn" data-video-id="${videoId}"><i class="fa-solid fa-xmark"></i></button>`;
    const inputArea = createCommentInputAndCloseHtml(videoId);

    // üî• Structure optimis√©e pour le scroll infini
    return `
        <div class="comments-content-wrapper"> 
            ${closeBtnHtml} 
            <div class="existing-comments" data-video-id="${videoId}">
                <!-- Les commentaires seront ins√©r√©s ici -->
                <div class="comments-loading" style="display:none;">
                    <p>‚è≥ Chargement...</p>
                </div>
            </div>
        </div>
        ${inputArea}
    `;
}

// ‚úÖ 3. Fonction pour charger les commentaires (pagination backend)
function loadComments(videoId, page = 0, append = false) {
    const state = commentsPagination.get(videoId) || { page: -1, hasMore: true, loading: false };
    
    // √âviter les chargements simultan√©s
    if (state.loading || !state.hasMore) {
        console.log(`‚è∏Ô∏è Chargement ignor√© pour vid√©o ${videoId} (loading=${state.loading}, hasMore=${state.hasMore})`);
        return Promise.resolve();
    }
    
    // Mise √† jour de l'√©tat
    state.loading = true;
    commentsPagination.set(videoId, state);
    
    // Afficher le loader
    const loader = document.querySelector(`#comments-section-${videoId} .comments-loading`);
    if (loader) loader.style.display = 'block';
    
    console.log(`üì• Chargement commentaires - Vid√©o: ${videoId}, Page: ${page}`);
    
    return fetch(`/videos/${videoId}/comments?page=${page}&size=10`)
        .then(res => {
            if (!res.ok) throw new Error(`Erreur HTTP ${res.status}`);
            return res.json();
        })
        .then(apiResponse => {
            if (!apiResponse.success || !apiResponse.data) {
                throw new Error("Format API invalide");
            }
            
            const commentsData = apiResponse.data;
            const commentsArray = commentsData.comments || [];
            const totalCount = commentsData.totalCount || 0;
            
            console.log(`‚úÖ Re√ßu ${commentsArray.length} commentaires (total: ${totalCount})`);
            
            // Mise √† jour du compteur
            const countSpan = document.getElementById(`comment-count-span-${videoId}`);
            if (countSpan) countSpan.textContent = totalCount;
            
            // Trouver le conteneur
            const container = document.querySelector(`#comments-section-${videoId} .existing-comments`);
            
            if (container) {
                if (!append) {
                    // Premier chargement : vider le conteneur (sauf le loader)
                    const loader = container.querySelector('.comments-loading');
                    container.innerHTML = '';
                    if (loader) container.appendChild(loader);
                }
                
                // Ins√©rer les nouveaux commentaires
                const commentsHtml = commentsArray.map(c => createCommentElement(c)).join('');
                const loader = container.querySelector('.comments-loading');
                
                if (loader) {
                    // üî• IMPORTANT : Ajouter AVANT le loader (scroll vers le haut)
                    loader.insertAdjacentHTML('afterend', commentsHtml);
                } else {
                    container.insertAdjacentHTML('beforeend', commentsHtml);
                }
                
                // Scroll en bas (seulement pour le premier chargement)
                if (!append) {
                    setTimeout(() => {
                        container.scrollTop = container.scrollHeight;
                    }, 100);
                }
            }
            
            // Mise √† jour de l'√©tat de pagination
            state.page = page;
            state.hasMore = commentsArray.length === 10; // S'il y a 10 r√©sultats, il y en a peut-√™tre plus
            state.loading = false;
            commentsPagination.set(videoId, state);
            
            console.log(`üìä √âtat pagination vid√©o ${videoId}:`, state);
            
        })
        .catch(error => {
            console.error(`‚ùå Erreur chargement commentaires:`, error);
            state.loading = false;
            state.hasMore = false;
            commentsPagination.set(videoId, state);
        })
        .finally(() => {
            // Masquer le loader
            if (loader) loader.style.display = 'none';
        });
}

// ‚úÖ 4. Observer le scroll pour charger automatiquement
function setupCommentsScrollObserver(videoId) {
    const container = document.querySelector(`#comments-section-${videoId} .existing-comments`);
    
    if (!container) {
        console.warn(`‚ö†Ô∏è Conteneur de commentaires introuvable pour vid√©o ${videoId}`);
        return;
    }
    
    // √âviter les observers multiples
    if (container.dataset.scrollObserver === 'true') {
        console.log(`‚úÖ Observer d√©j√† actif pour vid√©o ${videoId}`);
        return;
    }
    
    container.dataset.scrollObserver = 'true';
    
    container.addEventListener('scroll', () => {
        const state = commentsPagination.get(videoId);
        
        if (!state || state.loading || !state.hasMore) return;
        
        // D√©tecter si on est proche du haut (scroll infini invers√©)
        const scrollTop = container.scrollTop;
        const triggerPoint = 200; // Charger 200px avant d'atteindre le haut
        
        if (scrollTop < triggerPoint) {
            console.log(`üîÑ Scroll d√©tect√© - Chargement page ${state.page + 1}`);
            
            // Sauvegarder la position de scroll actuelle
            const oldScrollHeight = container.scrollHeight;
            
            loadComments(videoId, state.page + 1, true).then(() => {
                // Restaurer la position relative apr√®s ajout
                const newScrollHeight = container.scrollHeight;
                container.scrollTop = newScrollHeight - oldScrollHeight + scrollTop;
            });
        }
    });
    
    console.log(`üëÄ Observer de scroll activ√© pour vid√©o ${videoId}`);
}

// --- GESTION DES CLICS GLOBALE ---
document.querySelector('#video-container').addEventListener('click', function(event){
        const videoCard = event.target.closest('.video-card');
        if(!videoCard) return;

    // Logique de suppression de vid√©o (DELETE)
    const deleteBtn = event.target.closest('.delete-video-btn');
    if(deleteBtn){
        const videoId = deleteBtn.dataset.videoId;
        // Remplacer par un modal UI personnalis√© pour √©viter window.confirm
        if(!confirm("√ätes-vous s√ªr de vouloir supprimer d√©finitivement cette vid√©o et tous ses commentaires/likes ?")) return; 
        fetch(`/videos/${videoId}`, { method: "DELETE", headers: getAuthHeaders('text/plain') })
        .then(res => {
            if (res.ok || res.redirected) {
                videoCard.remove();
            } else {
                res.json().then(data => alert(`Erreur de suppression de vid√©o: ${data.error}`)).catch(()=>alert("Erreur inconnue lors de la suppression."));
            }
        })
        .catch(console.error);
        return;
    }

    // Logique de suppression de commentaire (DELETE)
    const deleteCommentBtn = event.target.closest('.delete-comment-btn');
    if(deleteCommentBtn){
        const btn = deleteCommentBtn;
        const commentId = btn.dataset.commentId;
        // Remplacer par un modal UI personnalis√© pour √©viter window.confirm
        if(!confirm("√ätes-vous s√ªr de vouloir supprimer ce commentaire ?")) return;

       fetch(`/videos/comments/${commentId}`, { method: "DELETE", headers: getAuthHeaders('text/plain') })
       .then(res => {
            if(res.ok) {
                const commentElement = btn.closest('.comment');
                
                const videoCard = btn.closest('.video-card'); 
                
                if(commentElement && videoCard) {
                    const videoId = videoCard.dataset.videoId;
                    commentElement.remove();

                    // D√©cr√©mentation locale du compteur
                    const countSpan = document.getElementById(`comment-count-span-${videoId}`);
                    if (countSpan) { countSpan.textContent = Math.max(0, (parseInt(countSpan.textContent) || 0) - 1); }
                
                } else if (commentElement) {
                    commentElement.remove();
                }
            } else { 
                // Gestion de l'erreur du serveur si res.ok est false
                res.json().then(data => alert(`Erreur de suppression de commentaire: ${data.error}`)).catch(()=>alert("Erreur inconnue lors de la suppression."));
            }
       })
       .catch(console.error);
       return;
    }

    // Logique d'√©dition/mise √† jour de commentaire (PUT)
    const editCommentBtn = event.target.closest('.edit-comment-btn');
    if (editCommentBtn) {
        const btn = editCommentBtn;
        const commentElement = btn.closest('.comment');
        const contentParagraph = commentElement ? commentElement.querySelector('.comment-content') : null;
        
        if (!commentElement || !contentParagraph) return;
        
        // Mode ENREGISTREMENT (si on est en mode 'editing')
        if (commentElement.classList.contains('editing')) {
            const textarea = commentElement.querySelector('textarea.edit-comment-input');
            const newContent = textarea ? textarea.value.trim() : null;
            const commentId = btn.dataset.commentId;

            if (!newContent) {
                alert("Le commentaire ne peut pas √™tre vide."); // Remplacer par un modal
                return;
            }

            // R√©cup√©ration du contenu original stock√©
            const originalContent = contentParagraph.dataset.originalContent || '';

            if (newContent === originalContent) {
                 // Pas de changement, annuler l'√©dition
                commentElement.classList.remove('editing');
                contentParagraph.textContent = originalContent; 
                delete contentParagraph.dataset.originalContent;
                // R√©tablit l'ic√¥ne
                btn.querySelector('i').classList.remove('fa-save');
                btn.querySelector('i').classList.add('fa-pen');
                // Supprime le bouton d'annulation
                commentElement.querySelector('.cancel-edit-btn')?.remove();
                return;
            }
            
            // Envoi de la requ√™te PUT
            fetch(`/videos/comments/${commentId}`, { 
                method: "PUT", 
                headers: getAuthHeaders(), 
                body: JSON.stringify({ content: newContent }) 
            })
            .then(res => {
                if (!res.ok) throw new Error("√âchec de la mise √† jour du commentaire.");
                return res.json();
            })
            .then(() => {
                // La mise √† jour du DOM pour tous se fera via WebSocket (handleUpdatedComment)
                console.log("Commentaire mis √† jour. Notification WebSocket envoy√©e.");
            })
            .catch(error => { 
                console.error(error); 
                alert(`Erreur de mise √† jour: ${error.message}`); // Remplacer par un modal
            });
            
            // Quitte le mode √©dition imm√©diatement pour le feedback UI
            commentElement.classList.remove('editing');
            delete contentParagraph.dataset.originalContent;
            // R√©tablit l'ic√¥ne de stylo
            btn.querySelector('i').classList.remove('fa-save');
            btn.querySelector('i').classList.add('fa-pen');
            // Supprime le bouton d'annulation
            commentElement.querySelector('.cancel-edit-btn')?.remove();
            
            return;
        } 
        // Mode √âDITION (si on n'est PAS en mode 'editing')
        else {
            // Optionnel : D√©sactiver l'√©dition des autres commentaires
            // (Laisser comme √ßa pour l'instant pour la simplicit√©)

            commentElement.classList.add('editing');
            
            const currentContent = contentParagraph.textContent.trim();
            const textareaHtml = `<textarea class="edit-comment-input" maxlength="500">${currentContent}</textarea>`; 
            
            // Sauvegarde de l'ancien contenu dans un attribut de donn√©es du paragraphe (pour l'annulation)
            contentParagraph.dataset.originalContent = currentContent;
            
            // Remplacer le contenu par la zone de texte
            contentParagraph.innerHTML = textareaHtml; 
            
            // Changer l'ic√¥ne en enregistrement
            btn.querySelector('i').classList.remove('fa-pen');
            btn.querySelector('i').classList.add('fa-save'); 
            
            // Ajouter un bouton d'annulation temporaire
            const cancelBtnHtml = `<button class="cancel-edit-btn action-btn" data-comment-id="${btn.dataset.commentId}" type="button"><i class="fa-solid fa-xmark"></i></button>`;
            
            // Ins√®re le bouton seulement s'il n'existe pas d√©j√†
            if (!commentElement.querySelector('.cancel-edit-btn')) {
                btn.parentElement.insertAdjacentHTML('beforeend', cancelBtnHtml);
            } 
            
            // Focus sur la zone de texte
            const textarea = commentElement.querySelector('textarea.edit-comment-input');
            if(textarea) {
                textarea.focus();
                textarea.select(); 
            }
        }
        return;
    }
    
    // Logique d'annulation d'√©dition de commentaire
    const cancelEditBtn = event.target.closest('.cancel-edit-btn');
    if (cancelEditBtn) {
        const commentElement = cancelEditBtn.closest('.comment');
        const contentParagraph = commentElement.querySelector('.comment-content');
        const editBtn = commentElement.querySelector('.edit-comment-btn');
        
        // Restaure le contenu original
        if (contentParagraph && contentParagraph.dataset.originalContent) {
             contentParagraph.textContent = contentParagraph.dataset.originalContent;
             delete contentParagraph.dataset.originalContent; // Nettoyage
        }
        
        commentElement.classList.remove('editing');
        
        // R√©tablit l'ic√¥ne
        if (editBtn) {
            editBtn.querySelector('i').classList.remove('fa-save');
            editBtn.querySelector('i').classList.add('fa-pen');
        }
        // Supprime le bouton d'annulation
        cancelEditBtn.remove();
        return;
    }

        // ========================================
    // üî• AJOUT : LOGIQUE DE LIKE (d√©placer depuis le 2e √©couteur)
    // ========================================
    const likeBtn = event.target.closest('.like-btn');
    if (likeBtn) {
        const videoId = likeBtn.dataset.videoId;
        
        const span = document.getElementById('likes-count-' + videoId);
        const icon = likeBtn.querySelector('i');

        const isCurrentlyLiked = icon.classList.contains('fa-solid');
        let currentLikes = parseInt(span.textContent) || 0;

        const savedIconClasses = icon.className;
        const savedLikesText = span.textContent;
        
        if (isCurrentlyLiked) {
            icon.classList.remove('fa-solid'); icon.classList.add('fa-regular');
            span.textContent = Math.max(0, currentLikes - 1);
        } else {
            icon.classList.remove('fa-regular'); icon.classList.add('fa-solid');
            span.textContent = currentLikes + 1;
        }

        fetch(`/videos/${videoId}/like`, { method: "POST", headers: getAuthHeaders() })
        .then(res => {
            if (!res.ok) {
                icon.className = savedIconClasses;
                span.textContent = savedLikesText;
                throw new Error("Action √©chou√©e, code: " + res.status); 
            }
            return res.json();
        })
        .then(data => {
            span.textContent = `${data.data}`;
            
            if (data.data > currentLikes) {
                icon.classList.remove('fa-regular'); icon.classList.add('fa-solid');
            } else {
                icon.classList.remove('fa-solid'); icon.classList.add('fa-regular');
            }
        })
        .catch(error => {
            console.error(`Erreur like pour Vid√©o ${videoId}:`, error);
        });
        return;
    }

    // ========================================
    // üî• AJOUT : ENVOI DE COMMENTAIRE (d√©placer depuis le 2e √©couteur)
    // ========================================
 const submitCommentBtn = event.target.closest('.submit-comment');
if(submitCommentBtn){
    const videoId = submitCommentBtn.dataset.videoId;
    const input = document.querySelector(`#comment-input-${videoId}`);
    const content = input.value.trim();
    if(!content) return;

    fetch(`/videos/${videoId}/comment`, { 
        method: 'POST', 
        headers: getAuthHeaders(), 
        body: JSON.stringify({ content }) 
    })
    .then(res => { 
        if (!res.ok) throw new Error("√âchec de l'envoi du commentaire."); 
        return res.json();
    })
    .then(data => {
        input.value = '';

        // ‚úÖ Ajout direct au DOM (le WebSocket g√©rera la diffusion aux autres)
        const container = document.querySelector(`#comments-section-${videoId} .existing-comments`);
        if (container) {
            const loader = container.querySelector('.comments-loading');
            const newCommentHtml = createCommentElement(data.comment);
            
            if (loader) {
                loader.insertAdjacentHTML('beforebegin', newCommentHtml);
            } else {
                container.insertAdjacentHTML('beforeend', newCommentHtml);
            }
            
            // Scroll en bas
            container.scrollTop = container.scrollHeight;
        }

        // ‚úÖ Mise √† jour du compteur
        const countSpan = document.getElementById(`comment-count-span-${videoId}`);
        if (countSpan) {
            countSpan.textContent = parseInt(countSpan.textContent || 0) + 1;
        }
    })
    .catch(error => { 
        console.error(`√âchec lors de l'envoi du commentaire: ${error.message}`); 
    });
}

    
    // LOGIQUE D'OUVERTURE/FERMETURE DES COMMENTAIRES
    const commentToggleBtn = event.target.closest('.comment-btn'); 
    const closeBtn = event.target.closest('.close-comments-btn'); 

    // 1. G√©rer la fermeture (bouton 'X')
    if (closeBtn) { 
        const videoId = closeBtn.dataset.videoId;
        closeCommentsSection(videoId); // Utilisation de la nouvelle fonction pour la transition fluide
        return; 
    }
// 2. G√©rer l'ouverture (bouton 'üí¨ commentaires')
if (commentToggleBtn) {
    const videoId = commentToggleBtn.dataset.videoId;
    const section = document.getElementById('comments-section-' + videoId);
    
    // Si d√©j√† affich√©e, on ferme (logique de toggle)
    if (videoCard.classList.contains('comments-open')) {
          closeCommentsSection(videoId);
          return;
    }

    // --- LOGIQUE D'OUVERTURE ET DE CHARGEMENT ---
    
    // Assure que display: block est l√† AVANT d'ajouter comments-open pour d√©clencher la transition
    section.style.display = 'block';
    section.offsetHeight; // <-- Ceci est la ligne de correction
    
    // D√©clenche la transition CSS (transform: translateY(0))
    videoCard.classList.add('comments-open'); 
 section.innerHTML = createCommentSectionContent([], videoId);
    commentsPagination.set(videoId, { page: -1, hasMore: true, loading: false });
    
    loadComments(videoId, 0, false).then(() => {
        setupCommentsScrollObserver(videoId);
    });
    
    return; // <-- L'accolade de fermeture du 'if (commentToggleBtn)' est ici
    
}
});

/**
 * G√®re le like/unlike d'une vid√©o avec mise √† jour optimiste de l'UI
 * @param {number} videoId - L'ID de la vid√©o √† liker
 */
function likeVideo(videoId) {
    const heartIcon = document.getElementById('like-icon-svg-' + videoId);
    const counter = document.getElementById('likes-count-span-' + videoId);
    
    if (!heartIcon || !counter) {
        console.error(`‚ùå √âl√©ments non trouv√©s pour la vid√©o ${videoId}`);
        return;
    }
    
    // 1. üé® Mise √† jour INSTANTAN√âE de l'UI (optimiste)
    const wasLiked = heartIcon.classList.contains('liked');
    heartIcon.classList.toggle('liked');
    
    let currentCount = parseInt(counter.textContent) || 0;
    const newOptimisticCount = wasLiked ? currentCount - 1 : currentCount + 1;
    counter.textContent = newOptimisticCount;
    
    console.log(`üîÑ [Optimiste] Like ${wasLiked ? 'retir√©' : 'ajout√©'} pour vid√©o ${videoId}`);
    
    // 2. üì° Envoi de la requ√™te au backend
    fetch(`/videos/${videoId}/like`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            // ‚úÖ Ajout du token CSRF (n√©cessaire pour Spring Security)
            [csrfHeader]: csrfToken
        },
        credentials: 'same-origin'
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Erreur HTTP: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        if (data.success && data.data !== null && data.data !== undefined) {
            // ‚úÖ Confirmation : synchroniser avec la valeur EXACTE du serveur
            counter.textContent = data.data;
            console.log(`‚úÖ [REST] Confirmation serveur: ${data.data} likes`);
        } else {
            console.warn('‚ö†Ô∏è R√©ponse inattendue du serveur:', data);
            // Rollback en cas d'erreur
            heartIcon.classList.toggle('liked');
            counter.textContent = currentCount;
        }
    })
    .catch(error => {
        console.error('‚ùå Erreur lors du like:', error);
        
        // üîÑ Rollback de l'UI en cas d'erreur r√©seau
        heartIcon.classList.toggle('liked');
        counter.textContent = currentCount;
        
        alert('Impossible de liker la vid√©o. Veuillez r√©essayer.');
    });
}
        // 6. WEBSOCKETS (STOMP/SockJS) - MODIFI√â POUR LE SCOPING PAR VID√âO
       
// === NOUVEAU : gestion des batches de commentaires ===
function handleNewCommentsBatch(payload) {
    const messages = Array.isArray(payload) ? payload : [payload];
    const videoId = messages[0]?.videoId;
    
    // üîç DEBUG 1
    console.log(`üîî WebSocket re√ßu pour vid√©o ${videoId}:`, messages);
    
    const existingCommentsContainer = document.querySelector(`#comments-section-${videoId} .existing-comments`);
    const countSpan = document.getElementById(`comment-count-span-${videoId}`);

    // üîç DEBUG 2
    console.log(`üì¶ Conteneur trouv√©:`, existingCommentsContainer ? 'OUI ‚úÖ' : 'NON ‚ùå');
    console.log(`üî¢ Compteur trouv√©:`, countSpan ? `OUI (${countSpan.textContent})` : 'NON ‚ùå');

    let newCommentCount = 0;

    messages.forEach(message => {
        const commentDto = message.comment; 
        
        if (message.action === "CREATED" && commentDto) {
            const commentId = commentDto.commentId || commentDto.id;
            
            // üîç DEBUG 3
            console.log(`‚ûï Tentative d'ajout du commentaire ${commentId}`);
            
            const existingComment = document.querySelector(`.comment[data-comment-id="${commentId}"]`);
            
            if (existingComment) {
                console.log(`‚ö†Ô∏è Commentaire ${commentId} d√©j√† pr√©sent, skip.`);
                return;
            }
            
            if (existingCommentsContainer) {
                const newCommentHtml = createCommentElement(commentDto);
                existingCommentsContainer.insertAdjacentHTML('beforeend', newCommentHtml);
                
                // üîç DEBUG 4
                console.log(`‚úÖ Commentaire ${commentId} ajout√© au DOM`);
            } else {
                // üîç DEBUG 5
                console.error(`‚ùå PROBL√àME: Le conteneur .existing-comments n'existe pas !`);
            }
            newCommentCount++;
        }
    });

    if (existingCommentsContainer) {
        existingCommentsContainer.scrollTop = existingCommentsContainer.scrollHeight;
    }

   
}



       function handleDeletedComment(payload) {
    if (payload.action === "DELETED") {
        const commentElement = document.querySelector(`.comment[data-comment-id="${payload.commentId}"]`);
        if (commentElement) commentElement.remove();

        // ‚úÖ Toujours utiliser le compteur exact envoy√© par le backend
        const countSpan = document.getElementById(`comment-count-span-${payload.videoId}`);
        if (countSpan && payload.newCommentsCount !== undefined) {
            countSpan.textContent = payload.newCommentsCount;
        }
            }
        }
      function handleUpdatedComment(payload) {
    if (payload.action === "UPDATED") {
        // üéØ R√©cup√®re le DTO complet
        const updatedCommentDto = payload.comment; 
        
        if (!updatedCommentDto) return;

        const commentElement = document.querySelector(`.comment[data-comment-id="${updatedCommentDto.id}"]`);
        
        if (commentElement) {
            // Remplacer l'ancien √©l√©ment par le nouvel √©l√©ment HTML g√©n√©r√© par le DTO mis √† jour
            // Cela g√®re automatiquement la mise √† jour du contenu et de la date.
            commentElement.outerHTML = createCommentElement(updatedCommentDto);
        }
        
        // Note: Vous n'avez plus besoin de retirer la classe 'editing' ici, car l'√©l√©ment
        // entier est remplac√© et le formulaire d'√©dition dispara√Æt si l'utilisateur l'avait.
    }
}
  function handleVideoStatsUpdate(videoId, statsPayload) {
    const { newLikesCount, newCommentsCount } = statsPayload;

    console.log(`[WS] update video ${videoId}: likes=${newLikesCount}, comments=${newCommentsCount}`);

    function safeUpdate(idSuffix, value, videoId, retries = 20) {
        const el = document.getElementById(idSuffix + videoId);
        if (el) {
            el.textContent = value;
        } else if (retries > 0) {
            setTimeout(() => safeUpdate(idSuffix, value, videoId, retries - 1), 50);
        } else {
            console.warn(`Impossible de mettre √† jour ${idSuffix}${videoId}, √©l√©ment non trouv√©`);
        }
    }

    if (newLikesCount != null) safeUpdate('likes-count-span-', newLikesCount, videoId);
    if (newCommentsCount != null) safeUpdate('comment-count-span-', newCommentsCount, videoId);
}

    // =======================================================
// GESTION INTELLIGENTE DES ABONNEMENTS WEBSOCKET (CORRIG√â)
// =======================================================
const activeSubscriptions = new Map(); // Stocke les abonnements actifs

function subscribeToNewVideos() {
    if (!stompClient || !stompClient.connected) {
        console.warn("STOMP client not connected, skipping dynamic subscription.");
        return;
    }
    
    const videoCards = document.querySelectorAll('.video-card');

    videoCards.forEach(card => {
        const videoId = card.dataset.videoId;
        
        // Si d√©j√† abonn√©, on ignore
        if (!videoId || activeSubscriptions.has(videoId)) return;
        
        const subscriptions = [];
        console.log("üîó Tentative d'abonnement √† :", `/topic/videos/${videoId}/comments`);
    subscriptions.push(
    stompClient.subscribe('/topic/videos/' + videoId + '/comments', function (message) {
        const payload = JSON.parse(message.body);
        
        if (payload.comment && payload.comment.authorUsername === currentUsername) {
    console.log("üë§ C'est mon propre commentaire ‚Äî affichage instantan√© d√©j√† fait ?");
    // on laisse passer si le DOM ne contient pas d√©j√† ce commentaire
    const existingComment = document.querySelector(`.comment[data-comment-id="${payload.comment.id}"]`);
    if (existingComment) {
        console.log("‚úÖ D√©j√† visible, on ignore le doublon.");
        return;
    }
    console.log("üÜï Mon commentaire n'est pas encore dans le DOM, on l'ajoute quand m√™me.");
}

        
        handleNewCommentsBatch(payload);
    })
);
        
        
        subscriptions.push(
            stompClient.subscribe('/topic/videos/' + videoId + '/delete', function (message) {
                handleDeletedComment(JSON.parse(message.body));
            })
        );
        
        subscriptions.push(
            stompClient.subscribe('/topic/videos/' + videoId + '/update', function (message) {
                handleUpdatedComment(JSON.parse(message.body));
            })
        );
        
       subscriptions.push(
    stompClient.subscribe('/topic/video/' + videoId, function (message) {
        try {
            // üéØ √âTAPE CRUCIALE : D√©coder le JSON VideoStatsUpdateDto
            const statsPayload = JSON.parse(message.body);
            
            // üéØ Appel de la fonction de mise √† jour pour g√©rer le compteur et l'√©tat
            handleVideoStatsUpdate(videoId, statsPayload);
            
            console.log(`[Stats Update] Vid√©o ${videoId} mise √† jour:`, statsPayload);

        } catch (e) {
            console.error("Erreur de parsing du payload stats:", e, message.body);
        }
    })
);
        
        // Stocker les abonnements pour cette vid√©o
        activeSubscriptions.set(videoId, subscriptions);
        console.log(`‚úÖ Abonn√© √† la vid√©o ${videoId}`);
    });
    
    // üî• AJOUT CRITIQUE : Nettoyer les abonnements invisibles
    cleanupInvisibleSubscriptions();
}

// üî• NOUVELLE FONCTION : D√©sabonner les vid√©os hors √©cran
function cleanupInvisibleSubscriptions() {
    const visibleIds = new Set();
    const cards = document.querySelectorAll('.video-card');
    
    // Identifier les vid√©os visibles + buffer de 5 suivantes
    cards.forEach((card, index) => {
        const rect = card.getBoundingClientRect();
        const isInViewport = rect.top < window.innerHeight + 1000 && rect.bottom > -1000;
        
        if (isInViewport || index < 5) {
            visibleIds.add(card.dataset.videoId);
        }
    });
    
    // D√©sabonner les vid√©os qui ne sont plus visibles
    activeSubscriptions.forEach((subscriptions, videoId) => {
        if (!visibleIds.has(videoId)) {
            // D√©sabonner tous les topics de cette vid√©o
            subscriptions.forEach(sub => sub.unsubscribe());
            activeSubscriptions.delete(videoId);
            console.log(`‚ùå D√©sabonn√© de la vid√©o ${videoId}`);
        }
    });
    
    console.log(`üìä Abonnements WebSocket actifs: ${activeSubscriptions.size}`);
}
        // 7. Lancement de la connexion et des Observateurs - FINALIS√â

// ‚ùå SUPPRIMER ENTI√àREMENT CES FONCTIONS OBSOL√àTES
/*
function debounce(func, delay) {
    let timeout;
    return function() {
        const context = this;
        const args = arguments;
        clearTimeout(timeout);
        timeout = setTimeout(() => func.apply(context, args), delay);
    };
}
// SUPPRIMER CETTE VARIABLE OBSOL√àTE
const debouncedCheckVideosInView = debounce(checkVideosInView, 100);
*/ 
// =======================================================
// NETTOYAGE AUTOMATIQUE P√âRIODIQUE
// =======================================================
// Lancer un nettoyage automatique toutes les 5 secondes
setInterval(() => {
    if (stompClient && stompClient.connected) {
        cleanupInvisibleSubscriptions();
    }
    
    // Logs pour debug (vous pouvez retirer en production)
    console.log('üßπ Nettoyage automatique effectu√©');
    console.log(`üìä Vid√©os en DOM: ${document.querySelectorAll('.video-card').length}`);
    console.log(`üìä Abonnements WebSocket: ${activeSubscriptions.size}`);
}, 5000); // Toutes les 5 secondes

document.addEventListener('DOMContentLoaded', () => {

    // 1. Initialisation et Connexion STOMP
    const socket = new SockJS('/ws');
    stompClient = Stomp.over(socket);
    const headers = {};
    if (csrfHeader && csrfToken) {
        headers[csrfHeader] = csrfToken;
    }
    // Fonction de connexion/reconnexion
    const connectToStomp = () => {
        stompClient.connect(headers, function (frame) {
            console.log('WebSocket Connected: ' + frame);
            
            // üéØ Appel pour abonner les vid√©os initiales de la page
            subscribeToNewVideos();

        }, function(error) {
            console.error('STOMP Connection Error:', error);
            // Tente de se reconnecter apr√®s 5 secondes
            setTimeout(connectToStomp, 5000);
        });
    };
    connectToStomp(); // Lance la connexion initiale
    
    // 2. Lie les √©couteurs de clic pour le MUTE (initialisation)
    setupMuteToggles();

    fixVideoTitlePosition();
    
    // ‚úÖ Remplacement de l'ancien checkVideosInView() par la nouvelle m√©thode optimis√©e
    setupVideoPlayObserver(); 
    
    // 5. D√©marre l'observation de la derni√®re vid√©o (le scroll infini)
    setupIntersectionObserver();

    
});
        
    </script>

</body>
</html>